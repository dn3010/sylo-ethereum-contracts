// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "../Token.sol";
import "../Payments/Ticketing/RewardsManager.sol";
import "../Epochs/Manager.sol";

/*
 * Manages stakes and delegated stakes for accounts that wish to be listed
*/
contract StakingManager is Initializable, OwnableUpgradeable {
    /* ERC 20 compatible token we are dealing with */
    IERC20 _token;

    /*
     * Rewards Manager contract. Any changes to stake will automatically
     * trigger a claim to any outstanding rewards
     */
    RewardsManager _rewardsManager;

    EpochsManager _epochsManager;

    struct StakeEntry {
        uint256 amount;

        // Block number this entry was updated at
        uint256 updatedAt;

        // Epoch this entry was updated. The stake will become active
        // in the following epoch
        uint256 epochId;
    }

    /*
     * Every Node must have stake in order to participate in the Epoch.
     * Stake can be provided by the Node itself or by other accounts in
     * the network.
     */
    struct Stake {
        // Track each stake entry associated to a node
        mapping (address => StakeEntry) stakeEntries;

        // The total stake held by this contract for a node,
        // which will be the sum of all addStake and unlockStake calls
        uint256 totalManagedStake;
    }

    struct Unlock {
        uint256 amount; // Amount of stake unlocking
        uint256 unlockAt; // Block number the stake becomes withdrawable
    }

    mapping (address => Stake) stakes;

    /* Tracks overall total stake */
    uint256 public totalManagedStake;

    /*
     * The number of blocks a user must wait after calling "unlock"
     * before they can withdraw their stake
     */
    uint256 public unlockDuration;

    /* Tracks funds that are in the process of being unlocked */
    mapping(bytes32 => Unlock) public unlockings;

    function initialize(
        IERC20 token,
        RewardsManager rewardsManager,
        EpochsManager epochsManager,
        uint256 _unlockDuration
    ) public initializer {
        OwnableUpgradeable.__Ownable_init();
        _token = token;
        _rewardsManager = rewardsManager;
        _epochsManager = epochsManager;
        unlockDuration = _unlockDuration;
    }

    function setUnlockDuration(uint256 newUnlockDuration) public onlyOwner {
        unlockDuration = newUnlockDuration;
    }

    function addStake(uint256 amount, address stakee) public {
        addStake_(amount, stakee);
        _token.transferFrom(msg.sender, address(this), amount);
    }

    function addStake_(uint256 amount, address stakee) internal {
        require(stakee != address(0), "Address is null");
        require(amount != 0, "Cannot stake nothing");

        Stake storage stake = stakes[stakee];

        uint256 currentStake = getCurrentStakerAmount(stakee, msg.sender);

        // automatically claim any outstanding rewards generated by their existing stake
        _rewardsManager.claimStakingRewardsAsManager(stakee, msg.sender);

        uint256 currentEpochId = _epochsManager.currentIteration();

        stake.stakeEntries[msg.sender] = StakeEntry(
            currentStake + amount,
            block.number,
            currentEpochId
        );

        stake.totalManagedStake += amount;
    }

    function unlockStake(uint256 amount, address stakee) public returns (uint256) {
        Stake storage stake = stakes[stakee];

        uint256 currentStake = getCurrentStakerAmount(stakee, msg.sender);

        require(currentStake > 0, "Nothing to unstake");
        require(currentStake >= amount, "Cannot unlock more than staked");

        // automatically claim any outstanding rewards generated by their existing stake
        _rewardsManager.claimStakingRewardsAsManager(stakee, msg.sender);

        uint256 currentEpochId = _epochsManager.currentIteration();

        stake.stakeEntries[msg.sender] = StakeEntry(
            currentStake - amount,
            block.number,
            currentEpochId
        );

        stake.totalManagedStake -= amount;

        bytes32 key = getKey(stakee, msg.sender);

        // Keep track of when the stake can be withdrawn
        Unlock storage unlock = unlockings[key];

        uint256 unlockAt = block.number + unlockDuration;
        if (unlock.unlockAt < unlockAt) {
            unlock.unlockAt = unlockAt;
        }

        unlock.amount += amount;

        return unlockAt;
    }

    // Withdraw any unlocked stake.
    function withdrawStake(address stakee) public {
        bytes32 key = getKey(stakee, msg.sender);

        Unlock storage unlock = unlockings[key];

        require(unlock.unlockAt < block.number, "Stake not yet unlocked");
        require(unlock.amount > 0, "No amount to withdraw");

        uint256 amount = unlock.amount;

        delete unlockings[key];

        _token.transfer(msg.sender, amount);
    }

    // Reverse unlocking a certain amount of stake
    function cancelUnlocking(uint256 amount, address stakee) public {
        bytes32 key = getKey(stakee, msg.sender);

        Unlock storage unlock = unlockings[key];

        // TODO guard unlockAt

        if (amount == unlock.amount) {
            delete unlockings[key];
        } else {
            require(amount < unlock.amount, "Unlock has insufficient amount");
            unlock.amount -= amount;
        }

        addStake_(amount, stakee);
    }

    function getKey(address stakee, address staker) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(stakee, staker));
    }

    function getTotalManagedStake() public view returns (uint256) {
        return totalManagedStake;
    }

    function getStakeEntry(address stakee, address staker) public view returns (StakeEntry memory) {
        return stakes[stakee].stakeEntries[staker];
    }

    function getCurrentStakerAmount(address stakee, address staker) public view returns (uint256) {
        return stakes[stakee].stakeEntries[staker].amount;
    }

    function getStakeeTotalManagedStake(address stakee) public view returns (uint256) {
        return stakes[stakee].totalManagedStake;
    }
}