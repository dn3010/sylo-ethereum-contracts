{
  "address": "0x8185e90E424116c67D8429Be71006941679E08bB",
  "abi": [
    {
      "inputs": [],
      "name": "AccountCannotBeZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ContractNameCannotBeEmpty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EscrowAmountCannotBeZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InterfaceIdCannotBeZeroBytes",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidReceiverSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidReceiverSigningPermission",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSenderSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSenderSigningPermission",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "MissingFuturepassAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoEsrowAndPenalty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PenaltyAmountCannotBeZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RedeemerCommitMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "epochId",
          "type": "uint256"
        }
      ],
      "name": "RedeemerMustHaveJoinedEpoch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        }
      ],
      "name": "TargetContractCannotBeZeroAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "TargetNotSupportInterface",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TicketAlreadyRedeemed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TicketAlreadyUsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TicketCannotBeFromFutureBlock",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TicketEpochNotFound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TicketNotCreatedInTheEpoch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TicketNotWinning",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TicketReceiverCannotBeZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TicketRedeemerCannotBeZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TicketSenderCannotBeZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TokenCannotBeZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnlockDurationCannotBeZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnlockingInProcess",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnlockingNotCompleted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnlockingNotInProcess",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "epochId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "redeemer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "generationBlock",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "MultiReceiverRedemption",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "epochId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "redeemer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "generationBlock",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Redemption",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "SenderPenaltyBurnt",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "unlockDuration",
          "type": "uint256"
        }
      ],
      "name": "UnlockDurationUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "_authorizedAccounts",
      "outputs": [
        {
          "internalType": "contract AuthorizedAccounts",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_directory",
      "outputs": [
        {
          "internalType": "contract Directory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_epochsManager",
      "outputs": [
        {
          "internalType": "contract EpochsManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_futurepassRegistrar",
      "outputs": [
        {
          "internalType": "contract IFuturePassRegistrar",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_registries",
      "outputs": [
        {
          "internalType": "contract Registries",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_rewardsManager",
      "outputs": [
        {
          "internalType": "contract RewardsManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_stakingManager",
      "outputs": [
        {
          "internalType": "contract StakingManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_token",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "epochId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "generationBlock",
          "type": "uint256"
        }
      ],
      "name": "calculateWinningProbability",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "generationBlock",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "rand",
          "type": "uint256"
        }
      ],
      "name": "createCommit",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "depositEscrow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "depositPenalty",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "deposits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "escrow",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "penalty",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "unlockAt",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "epochId",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "main",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "delegated",
                  "type": "address"
                }
              ],
              "internalType": "struct ISyloTicketing.User",
              "name": "sender",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "redeemer",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "generationBlock",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "redeemerCommit",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ISyloTicketing.MultiReceiverTicket",
          "name": "ticket",
          "type": "tuple"
        }
      ],
      "name": "getMultiReceiverTicketHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "epochId",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "main",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "delegated",
                  "type": "address"
                }
              ],
              "internalType": "struct ISyloTicketing.User",
              "name": "sender",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "main",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "delegated",
                  "type": "address"
                }
              ],
              "internalType": "struct ISyloTicketing.User",
              "name": "receiver",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "redeemer",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "generationBlock",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "redeemerCommit",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ISyloTicketing.Ticket",
          "name": "ticket",
          "type": "tuple"
        }
      ],
      "name": "getTicketHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "contract Registries",
          "name": "registries",
          "type": "address"
        },
        {
          "internalType": "contract StakingManager",
          "name": "stakingManager",
          "type": "address"
        },
        {
          "internalType": "contract Directory",
          "name": "directory",
          "type": "address"
        },
        {
          "internalType": "contract EpochsManager",
          "name": "epochsManager",
          "type": "address"
        },
        {
          "internalType": "contract RewardsManager",
          "name": "rewardsManager",
          "type": "address"
        },
        {
          "internalType": "contract AuthorizedAccounts",
          "name": "authorizedAccounts",
          "type": "address"
        },
        {
          "internalType": "contract IFuturePassRegistrar",
          "name": "futurepassRegistrar",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_unlockDuration",
          "type": "uint256"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "senderSig",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "receiverSig",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "epochId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "generationBlock",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "redeemerRand",
          "type": "uint256"
        }
      ],
      "name": "isWinningTicket",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lockDeposits",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "epochId",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "main",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "delegated",
                  "type": "address"
                }
              ],
              "internalType": "struct ISyloTicketing.User",
              "name": "sender",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "main",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "delegated",
                  "type": "address"
                }
              ],
              "internalType": "struct ISyloTicketing.User",
              "name": "receiver",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "redeemer",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "generationBlock",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "redeemerCommit",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ISyloTicketing.Ticket",
          "name": "ticket",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "redeemerRand",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "senderSig",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "receiverSig",
          "type": "bytes"
        }
      ],
      "name": "redeem",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "epochId",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "main",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "delegated",
                  "type": "address"
                }
              ],
              "internalType": "struct ISyloTicketing.User",
              "name": "sender",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "redeemer",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "generationBlock",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "redeemerCommit",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ISyloTicketing.MultiReceiverTicket",
          "name": "ticket",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "redeemerRand",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "main",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "delegated",
              "type": "address"
            }
          ],
          "internalType": "struct ISyloTicketing.User",
          "name": "receiver",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "senderSig",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "receiverSig",
          "type": "bytes"
        }
      ],
      "name": "redeemMultiReceiver",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "epochId",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "main",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "delegated",
                  "type": "address"
                }
              ],
              "internalType": "struct ISyloTicketing.User",
              "name": "sender",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "redeemer",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "generationBlock",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "redeemerCommit",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ISyloTicketing.MultiReceiverTicket",
          "name": "ticket",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "main",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "delegated",
              "type": "address"
            }
          ],
          "internalType": "struct ISyloTicketing.User",
          "name": "receiver",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "redeemerRand",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "senderSig",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "receiverSig",
          "type": "bytes"
        }
      ],
      "name": "requireValidWinningMultiReceiverTicket",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "ticketHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "ticketReceiverHash",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "epochId",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "main",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "delegated",
                  "type": "address"
                }
              ],
              "internalType": "struct ISyloTicketing.User",
              "name": "sender",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "main",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "delegated",
                  "type": "address"
                }
              ],
              "internalType": "struct ISyloTicketing.User",
              "name": "receiver",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "redeemer",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "generationBlock",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "redeemerCommit",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ISyloTicketing.Ticket",
          "name": "ticket",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "redeemerRand",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "senderSig",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "receiverSig",
          "type": "bytes"
        }
      ],
      "name": "requireValidWinningTicket",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "ticketHash",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_unlockDuration",
          "type": "uint256"
        }
      ],
      "name": "setUnlockDuration",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unlockDeposits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unlockDuration",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "usedTickets",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "withdrawTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x4ddfa0a931e5d92a7b37ba275747c2fb753d2dfd84681de938574fc1cc7d1936",
  "receipt": {
    "to": null,
    "from": "0x448c8e9e1816300Dd052e77D2A44c990A2807D15",
    "contractAddress": "0x8185e90E424116c67D8429Be71006941679E08bB",
    "transactionIndex": 0,
    "gasUsed": "2694323",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x50aff69108f52d6c6ca8db81c393b889df25d78bac8f9c02fd63d59f9786ed25",
    "transactionHash": "0x4ddfa0a931e5d92a7b37ba275747c2fb753d2dfd84681de938574fc1cc7d1936",
    "logs": [],
    "blockNumber": 10978380,
    "cumulativeGasUsed": "2694323",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "76c1e1f3445d6d518cb33f614f9922c9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccountCannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractNameCannotBeEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EscrowAmountCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterfaceIdCannotBeZeroBytes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReceiverSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReceiverSigningPermission\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSenderSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSenderSigningPermission\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"MissingFuturepassAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoEsrowAndPenalty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PenaltyAmountCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedeemerCommitMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"RedeemerMustHaveJoinedEpoch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"TargetContractCannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"TargetNotSupportInterface\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketAlreadyRedeemed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketAlreadyUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketCannotBeFromFutureBlock\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketEpochNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketNotCreatedInTheEpoch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketNotWinning\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketReceiverCannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketRedeemerCannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketSenderCannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenCannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnlockDurationCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnlockingInProcess\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnlockingNotCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnlockingNotInProcess\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MultiReceiverRedemption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redemption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SenderPenaltyBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockDuration\",\"type\":\"uint256\"}],\"name\":\"UnlockDurationUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_authorizedAccounts\",\"outputs\":[{\"internalType\":\"contract AuthorizedAccounts\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_directory\",\"outputs\":[{\"internalType\":\"contract Directory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_epochsManager\",\"outputs\":[{\"internalType\":\"contract EpochsManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_futurepassRegistrar\",\"outputs\":[{\"internalType\":\"contract IFuturePassRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_registries\",\"outputs\":[{\"internalType\":\"contract Registries\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardsManager\",\"outputs\":[{\"internalType\":\"contract RewardsManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_stakingManager\",\"outputs\":[{\"internalType\":\"contract StakingManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"}],\"name\":\"calculateWinningProbability\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rand\",\"type\":\"uint256\"}],\"name\":\"createCommit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"depositEscrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"depositPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"escrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"sender\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"redeemerCommit\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISyloTicketing.MultiReceiverTicket\",\"name\":\"ticket\",\"type\":\"tuple\"}],\"name\":\"getMultiReceiverTicketHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"receiver\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"redeemerCommit\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISyloTicketing.Ticket\",\"name\":\"ticket\",\"type\":\"tuple\"}],\"name\":\"getTicketHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract Registries\",\"name\":\"registries\",\"type\":\"address\"},{\"internalType\":\"contract StakingManager\",\"name\":\"stakingManager\",\"type\":\"address\"},{\"internalType\":\"contract Directory\",\"name\":\"directory\",\"type\":\"address\"},{\"internalType\":\"contract EpochsManager\",\"name\":\"epochsManager\",\"type\":\"address\"},{\"internalType\":\"contract RewardsManager\",\"name\":\"rewardsManager\",\"type\":\"address\"},{\"internalType\":\"contract AuthorizedAccounts\",\"name\":\"authorizedAccounts\",\"type\":\"address\"},{\"internalType\":\"contract IFuturePassRegistrar\",\"name\":\"futurepassRegistrar\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_unlockDuration\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"senderSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receiverSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemerRand\",\"type\":\"uint256\"}],\"name\":\"isWinningTicket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"receiver\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"redeemerCommit\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISyloTicketing.Ticket\",\"name\":\"ticket\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"redeemerRand\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"senderSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receiverSig\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"sender\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"redeemerCommit\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISyloTicketing.MultiReceiverTicket\",\"name\":\"ticket\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"redeemerRand\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"receiver\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"senderSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receiverSig\",\"type\":\"bytes\"}],\"name\":\"redeemMultiReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"sender\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"redeemerCommit\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISyloTicketing.MultiReceiverTicket\",\"name\":\"ticket\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"receiver\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"redeemerRand\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"senderSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receiverSig\",\"type\":\"bytes\"}],\"name\":\"requireValidWinningMultiReceiverTicket\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"ticketHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"ticketReceiverHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegated\",\"type\":\"address\"}],\"internalType\":\"struct ISyloTicketing.User\",\"name\":\"receiver\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"generationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"redeemerCommit\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISyloTicketing.Ticket\",\"name\":\"ticket\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"redeemerRand\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"senderSig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receiverSig\",\"type\":\"bytes\"}],\"name\":\"requireValidWinningTicket\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"ticketHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unlockDuration\",\"type\":\"uint256\"}],\"name\":\"setUnlockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedTickets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Initialized(uint8)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"calculateWinningProbability(uint256,uint256)\":{\"params\":{\"epochId\":\"The epochId of the ticket.\",\"generationBlock\":\"The generationBlock of the ticket.\"}},\"depositEscrow(uint256,address)\":{\"params\":{\"account\":\"The address of the account holding the escrow.\",\"amount\":\"The amount in SOLO to add to the escrow.\"}},\"depositPenalty(uint256,address)\":{\"params\":{\"account\":\"The address of the account holding the penalty.\",\"amount\":\"The amount in SOLO to add to the escrow.\"}},\"getMultiReceiverTicketHash((uint256,(address,address),address,uint256,bytes32))\":{\"returns\":{\"_0\":\"A byte-array representing the hash.\"}},\"getTicketHash((uint256,(address,address),(address,address),address,uint256,bytes32))\":{\"returns\":{\"_0\":\"A byte-array representing the hash.\"}},\"isWinningTicket(bytes,bytes,uint256,uint256,uint256)\":{\"params\":{\"epochId\":\"The epochId of the ticket.\",\"generationBlock\":\"The generationBlock of the ticket.\",\"receiverSig\":\"The signature of the receiver of the ticket.\",\"redeemerRand\":\"The redeemer random value, generated by the Node prior to performing the event relay.\",\"senderSig\":\"The signature of the sender of the ticket.\"},\"returns\":{\"_0\":\"True if a ticket is a winner.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"redeem((uint256,(address,address),(address,address),address,uint256,bytes32),uint256,bytes,bytes)\":{\"params\":{\"receiverSig\":\"The signature of the redeemer of the ticket.\",\"redeemerRand\":\"The redeemer random value, generated by the Node prior to performing the event relay.\",\"senderSig\":\"The signature of the sender of the ticket.\",\"ticket\":\"The ticket issued by the sender.\"}},\"redeemMultiReceiver((uint256,(address,address),address,uint256,bytes32),uint256,(address,address),bytes,bytes)\":{\"params\":{\"receiver\":\"A valid receiver of the the relay.\",\"receiverSig\":\"The signature of the redeemer of the ticket.\",\"redeemerRand\":\"The redeemer random value, generated by the Node prior to performing the event relay.\",\"senderSig\":\"The signature of the sender of the ticket.\",\"ticket\":\"The ticket issued by the sender.\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"requireValidWinningMultiReceiverTicket((uint256,(address,address),address,uint256,bytes32),(address,address),uint256,bytes,bytes)\":{\"params\":{\"receiver\":\"The receiver associated with the ticket.\",\"receiverSig\":\"The signature of the redeemer of the ticket.\",\"redeemerRand\":\"The redeemer random value, generated by the Node prior to performing the event relay.\",\"senderSig\":\"The signature of the sender of the ticket.\",\"ticket\":\"The ticket issued by the sender.\"}},\"requireValidWinningTicket((uint256,(address,address),(address,address),address,uint256,bytes32),uint256,bytes,bytes)\":{\"params\":{\"receiverSig\":\"The signature of the redeemer of the ticket.\",\"redeemerRand\":\"The redeemer random value, generated by the Node prior to performing the event relay.\",\"senderSig\":\"The signature of the sender of the ticket.\",\"ticket\":\"The ticket issued by the sender.\"},\"returns\":{\"ticketHash\":\"The hash of the ticket. Should match the hash generated by `getTicketHash`.\"}},\"setUnlockDuration(uint256)\":{\"params\":{\"_unlockDuration\":\"The unlock duration in blocks.\"}},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner.\"},\"withdrawTo(address)\":{\"params\":{\"account\":\"The address of the account the tokens should be transferred to.\"}}},\"stateVariables\":{\"_epochsManager\":{\"details\":\"The ticketing parameters used when redeeming tickets will be read from this contract.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"_authorizedAccounts()\":{\"notice\":\"Sylo Authorized Accounts.\"},\"_directory()\":{\"notice\":\"Sylo Directory contract \"},\"_epochsManager()\":{\"notice\":\"Sylo Epochs Manager.\"},\"_futurepassRegistrar()\":{\"notice\":\"Futurepass Registrar Pre-compile.\"},\"_registries()\":{\"notice\":\"Sylo Registries contract \"},\"_rewardsManager()\":{\"notice\":\"Rewards Manager contract \"},\"_stakingManager()\":{\"notice\":\"Sylo Staking Manager contract \"},\"_token()\":{\"notice\":\"ERC20 Sylo token contract.\"},\"calculateWinningProbability(uint256,uint256)\":{\"notice\":\"This function calculates the probability of a ticket winning at the block that this function was called. A ticket's winning probability will decay every block since its issuance. The amount of decay will depend on the decay rate parameter of the epoch the ticket was generated in.\"},\"depositEscrow(uint256,address)\":{\"notice\":\"Use this function to deposit funds into the escrow. This will fail if the deposit is currently being unlocked.\"},\"depositPenalty(uint256,address)\":{\"notice\":\"Use this function to deposit funds into the penalty. This will fail if the deposit is currently being unlocked.\"},\"deposits(address)\":{\"notice\":\"Mapping of user deposits \"},\"getMultiReceiverTicketHash((uint256,(address,address),address,uint256,bytes32))\":{\"notice\":\"Returns the hash of a multi receiver ticket. Takes all fields in a ticket as inputs to the hash, as well as a specific receiver.\"},\"getTicketHash((uint256,(address,address),(address,address),address,uint256,bytes32))\":{\"notice\":\"Returns the hash of the ticket. Takes all fields in a ticket as inputs to the hash.\"},\"isWinningTicket(bytes,bytes,uint256,uint256,uint256)\":{\"notice\":\"Use this function to check if a ticket is winning.\"},\"lockDeposits()\":{\"notice\":\"Call this function to cancel any deposit that is in the unlocking process.\"},\"redeem((uint256,(address,address),(address,address),address,uint256,bytes32),uint256,bytes,bytes)\":{\"notice\":\"Nodes should call this function on completing an event delivery. This function will fail if the ticket is invalid or if the ticket is not a winner. Clients should calculate if the ticket is a winner locally, but can also use the public view functions: `requireValidWinningTicket` and `isWinningTicket` to check that a ticket is winning.\"},\"redeemMultiReceiver((uint256,(address,address),address,uint256,bytes32),uint256,(address,address),bytes,bytes)\":{\"notice\":\"Nodes should call this function on completing a one-to-many event delivery. This function will fail if the ticket is invalid or if the ticket is not a winner. Additionally, the specified receiver must have a valid futurepass account associated with it. Clients should calculate if the ticket is a winner locally, but can also use the public view functions: `requireValidWinningMultiReceiverTicket` and `isWinningTicket` to check that a ticket is winning.\"},\"requireValidWinningMultiReceiverTicket((uint256,(address,address),address,uint256,bytes32),(address,address),uint256,bytes,bytes)\":{\"notice\":\"Call this function to check if a multi receiver ticket is valid and is a winning ticket. It will fail if the ticket is invalid or is not a winner. A ticket is invalid if:      - The sender, receiver or redeemer addresses are null      - The receiver does not have a valid futurepass account      - The ticket has already been redeemed.      - The secret random value of the redeemer does not match the commit        in the ticket.      - The signatures are invalid.\"},\"requireValidWinningTicket((uint256,(address,address),(address,address),address,uint256,bytes32),uint256,bytes,bytes)\":{\"notice\":\"Call this function to check if a ticket is valid and is a winning ticket. It will fail if the ticket is invalid or is not a winner. A ticket is invalid if:      - The sender or redeemer addresses are null      - The ticket has already been redeemed.      - The secret random value of the sender does not match the commit        in the ticket.      - The signatures are invalid.\"},\"setUnlockDuration(uint256)\":{\"notice\":\"Set the unlock duration for deposits. Only callable by the owner.\"},\"supportsInterface(bytes4)\":{\"notice\":\"Returns true if the contract implements the interface defined by `interfaceId` from ERC165.\"},\"unlockDeposits()\":{\"notice\":\"Call this function to begin unlocking deposits. This function will fail if no deposit exists, or if the unlock process has already begun.\"},\"unlockDuration()\":{\"notice\":\"The number of blocks a user must wait after calling \\\"unlock\\\" before they can withdraw their funds.\"},\"usedTickets(bytes32)\":{\"notice\":\"Mapping of ticket hashes, used to check if a ticket has been redeemed \"},\"withdraw()\":{\"notice\":\"Call this function once the unlock duration has elapsed in order to transfer the unlocked tokens to the caller's account.\"},\"withdrawTo(address)\":{\"notice\":\"Call this function once the unlock duration has elapsed in order to transfer the unlocked tokens to the specified account.\"}},\"notice\":\"The SyloTicketing contract manages the Probabilistic Micro-Payment Ticketing system that pays Nodes for providing the Event Relay service.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/payments/SyloTicketing.sol\":\"SyloTicketing\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x84efb8889801b0ac817324aff6acc691d07bbee816b671817132911d287a8c63\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x4075622496acc77fd6d4de4cc30a8577a744d5c75afad33fdeacf1704d6eda98\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa56ca923f70c1748830700250b19c61b70db9a683516dc5e216694a50445d99c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x909d608c2db6eb165ca178c81289a07ed2e118e444d0025b2a85c97d0b44a4fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"abdk-libraries-solidity/ABDKMath64x64.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /*\\n   * Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /*\\n   * Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (x << 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    unchecked {\\n      return int64 (x >> 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (int256 (x << 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    unchecked {\\n      require (x >= 0);\\n      return uint64 (uint128 (x >> 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = x >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    unchecked {\\n      return int256 (x) << 64;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) + y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) - y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) * y >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    unchecked {\\n      if (x == MIN_64x64) {\\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n          y <= 0x1000000000000000000000000000000000000000000000000);\\n        return -y << 63;\\n      } else {\\n        bool negativeResult = false;\\n        if (x < 0) {\\n          x = -x;\\n          negativeResult = true;\\n        }\\n        if (y < 0) {\\n          y = -y; // We rely on overflow behavior here\\n          negativeResult = !negativeResult;\\n        }\\n        uint256 absoluteResult = mulu (x, uint256 (y));\\n        if (negativeResult) {\\n          require (absoluteResult <=\\n            0x8000000000000000000000000000000000000000000000000000000000000000);\\n          return -int256 (absoluteResult); // We rely on overflow behavior here\\n        } else {\\n          require (absoluteResult <=\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n          return int256 (absoluteResult);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    unchecked {\\n      if (y == 0) return 0;\\n\\n      require (x >= 0);\\n\\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\\n\\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      hi <<= 64;\\n\\n      require (hi <=\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n      return hi + lo;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      int256 result = (int256 (x) << 64) / y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x; // We rely on overflow behavior here\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <= 0x80000000000000000000000000000000);\\n        return -int128 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (absoluteResult); // We rely on overflow behavior here\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      uint128 result = divuu (x, y);\\n      require (result <= uint128 (MAX_64x64));\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return -x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return x < 0 ? -x : x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != 0);\\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      return int128 ((int256 (x) + int256 (y)) >> 1);\\n    }\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 m = int256 (x) * int256 (y);\\n      require (m >= 0);\\n      require (m <\\n          0x4000000000000000000000000000000000000000000000000000000000000000);\\n      return int128 (sqrtu (uint256 (m)));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      bool negative = x < 0 && y & 1 == 1;\\n\\n      uint256 absX = uint128 (x < 0 ? -x : x);\\n      uint256 absResult;\\n      absResult = 0x100000000000000000000000000000000;\\n\\n      if (absX <= 0x10000000000000000) {\\n        absX <<= 63;\\n        while (y != 0) {\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x2 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x4 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x8 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          y >>= 4;\\n        }\\n\\n        absResult >>= 64;\\n      } else {\\n        uint256 absXShift = 63;\\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\n\\n        uint256 resultShift = 0;\\n        while (y != 0) {\\n          require (absXShift < 64);\\n\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n            resultShift += absXShift;\\n            if (absResult > 0x100000000000000000000000000000000) {\\n              absResult >>= 1;\\n              resultShift += 1;\\n            }\\n          }\\n          absX = absX * absX >> 127;\\n          absXShift <<= 1;\\n          if (absX >= 0x100000000000000000000000000000000) {\\n              absX >>= 1;\\n              absXShift += 1;\\n          }\\n\\n          y >>= 1;\\n        }\\n\\n        require (resultShift < 64);\\n        absResult >>= 64 - resultShift;\\n      }\\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= 0);\\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      int256 msb = 0;\\n      int256 xc = x;\\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      int256 result = msb - 64 << 64;\\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n        ux *= ux;\\n        uint256 b = ux >> 255;\\n        ux >>= 127 + b;\\n        result += bit * int256 (b);\\n      }\\n\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      return int128 (int256 (\\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      uint256 result = 0x80000000000000000000000000000000;\\n\\n      if (x & 0x8000000000000000 > 0)\\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n      if (x & 0x4000000000000000 > 0)\\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n      if (x & 0x2000000000000000 > 0)\\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n      if (x & 0x1000000000000000 > 0)\\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n      if (x & 0x800000000000000 > 0)\\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n      if (x & 0x400000000000000 > 0)\\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n      if (x & 0x200000000000000 > 0)\\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n      if (x & 0x100000000000000 > 0)\\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n      if (x & 0x80000000000000 > 0)\\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n      if (x & 0x40000000000000 > 0)\\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n      if (x & 0x20000000000000 > 0)\\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n      if (x & 0x10000000000000 > 0)\\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n      if (x & 0x8000000000000 > 0)\\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n      if (x & 0x4000000000000 > 0)\\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n      if (x & 0x2000000000000 > 0)\\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n      if (x & 0x1000000000000 > 0)\\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n      if (x & 0x800000000000 > 0)\\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n      if (x & 0x400000000000 > 0)\\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n      if (x & 0x200000000000 > 0)\\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n      if (x & 0x100000000000 > 0)\\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n      if (x & 0x80000000000 > 0)\\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n      if (x & 0x40000000000 > 0)\\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n      if (x & 0x20000000000 > 0)\\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n      if (x & 0x10000000000 > 0)\\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n      if (x & 0x8000000000 > 0)\\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n      if (x & 0x4000000000 > 0)\\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n      if (x & 0x2000000000 > 0)\\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n      if (x & 0x1000000000 > 0)\\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n      if (x & 0x800000000 > 0)\\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n      if (x & 0x400000000 > 0)\\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n      if (x & 0x200000000 > 0)\\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n      if (x & 0x100000000 > 0)\\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n      if (x & 0x80000000 > 0)\\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n      if (x & 0x40000000 > 0)\\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n      if (x & 0x20000000 > 0)\\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n      if (x & 0x10000000 > 0)\\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n      if (x & 0x8000000 > 0)\\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n      if (x & 0x4000000 > 0)\\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n      if (x & 0x2000000 > 0)\\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n      if (x & 0x1000000 > 0)\\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n      if (x & 0x800000 > 0)\\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n      if (x & 0x400000 > 0)\\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n      if (x & 0x200000 > 0)\\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n      if (x & 0x100000 > 0)\\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n      if (x & 0x80000 > 0)\\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n      if (x & 0x40000 > 0)\\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n      if (x & 0x20000 > 0)\\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n      if (x & 0x10000 > 0)\\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n      if (x & 0x8000 > 0)\\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n      if (x & 0x4000 > 0)\\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n      if (x & 0x2000 > 0)\\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n      if (x & 0x1000 > 0)\\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n      if (x & 0x800 > 0)\\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n      if (x & 0x400 > 0)\\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n      if (x & 0x200 > 0)\\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n      if (x & 0x100 > 0)\\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n      if (x & 0x80 > 0)\\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n      if (x & 0x40 > 0)\\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n      if (x & 0x20 > 0)\\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n      if (x & 0x10 > 0)\\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n      if (x & 0x8 > 0)\\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n      if (x & 0x4 > 0)\\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n      if (x & 0x2 > 0)\\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n      if (x & 0x1 > 0)\\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n      result >>= uint256 (int256 (63 - (x >> 64)));\\n      require (result <= uint256 (int256 (MAX_64x64)));\\n\\n      return int128 (int256 (result));\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      return exp_2 (\\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      uint256 result;\\n\\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        result = (x << 64) / y;\\n      else {\\n        uint256 msb = 192;\\n        uint256 xc = x >> 192;\\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 hi = result * (y >> 128);\\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 xh = x >> 192;\\n        uint256 xl = x << 64;\\n\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n        lo = hi << 128;\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n\\n        result += xh == hi >> 128 ? xl / y : 1;\\n      }\\n\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return uint128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\n    unchecked {\\n      if (x == 0) return 0;\\n      else {\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\n        if (xx >= 0x4) { r <<= 1; }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return uint128 (r < r1 ? r : r1);\\n      }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x1364fdc24192b982f647c7fc68dcb2f6fc1b5e201843e773144bd23a76cb3b97\",\"license\":\"BSD-4-Clause\"},\"contracts/AuthorizedAccounts.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nimport \\\"./interfaces/IAuthorizedAccounts.sol\\\";\\n\\n/**\\n * @notice Manages authorized accounts with limited permissions on behalf of main account\\n * these authorized accounts are allowed to perform some certain actions in the Sylo network\\n * in order to reduce the works for main account\\n */\\ncontract AuthorizedAccounts is\\n    IAuthorizedAccounts,\\n    Initializable,\\n    Ownable2StepUpgradeable,\\n    ERC165\\n{\\n    /**\\n     * @notice Tracks authorized accounts for every main account\\n     */\\n    mapping(address => AuthorizedAccount[]) public authorizedAccounts;\\n\\n    event PermissionsAdded(\\n        address indexed main,\\n        address indexed authorized,\\n        Permission[] permissions\\n    );\\n\\n    event PermissionsRemoved(\\n        address indexed main,\\n        address indexed authorized,\\n        Permission[] permissions\\n    );\\n\\n    error AuthorizedAccountCannotBeZeroAddress();\\n    error MainAccountCannotBeZeroAddress();\\n    error AtBlockNumberCannotBeZero();\\n    error AccountAlreadyAuthorized();\\n    error AccountDoesNotExist();\\n\\n    function initialize() external initializer {\\n        Ownable2StepUpgradeable.__Ownable2Step_init();\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract implements the interface defined by\\n     * `interfaceId` from ERC165.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAuthorizedAccounts).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Adds new authorized accounts with certain permissions.\\n     * This will revert if the account has already existed.\\n     * @param authorized The address that the main account wants to authorize\\n     * @param permissions The list of permissions that the authorized account\\n     * can perform within the Sylo network.\\n     */\\n    function authorizeAccount(address authorized, Permission[] calldata permissions) external {\\n        if (authorized == address(0)) {\\n            revert AuthorizedAccountCannotBeZeroAddress();\\n        }\\n\\n        // check if account has already been authorized\\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[msg.sender];\\n        for (uint i; i < authAccounts.length; ++i) {\\n            if (authAccounts[i].account == authorized) {\\n                if (authAccounts[i].authorizedAt != 0) {\\n                    revert AccountAlreadyAuthorized();\\n                }\\n\\n                authAccounts[i].authorizedAt = block.number;\\n                return _addPermissions(authorized, authAccounts[i], permissions);\\n            }\\n        }\\n\\n        // add new authorized account to the list\\n        authAccounts.push();\\n        AuthorizedAccount storage newAccount = authAccounts[authAccounts.length - 1];\\n        newAccount.account = authorized;\\n        newAccount.authorizedAt = block.number;\\n\\n        _addPermissions(authorized, newAccount, permissions);\\n    }\\n\\n    /**\\n     * @notice Removes all permissions of a specific authorized account\\n     * associated with the msg.sender, and sets the account's authorizedAt to 0.\\n     * Note: It does not remove the authorized account from the list.\\n     * This will revert if the account does not exist.\\n     * @param authorized The address of the authorized account\\n     */\\n    function unauthorizeAccount(address authorized) external {\\n        if (authorized == address(0)) {\\n            revert AuthorizedAccountCannotBeZeroAddress();\\n        }\\n\\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[msg.sender];\\n        for (uint i; i < authAccounts.length; ++i) {\\n            if (authAccounts[i].account == authorized) {\\n                delete authAccounts[i].authorizedAt;\\n                return _removePermissions(authorized, authAccounts[i], getAllPermissions());\\n            }\\n        }\\n\\n        revert AccountDoesNotExist();\\n    }\\n\\n    /**\\n     * @notice Adds new permissions to a specific authorized account.\\n     * - Adding permissions that don't exist in the Permission enum will return\\n     * with panic code 0x21 (convert a value that is too big or negative into an enum type).\\n     * - Adding duplicate permissions will update the permissions' authorizedAt value.\\n     * - Adding permissions that were previously unauthorized will update\\n     * the authorizedAt and unauthorizedAt values (refer to the comment in\\n     * IAuthorizedAccount -> AuthorizedPermission struct).\\n     * This will revert if the account does not exist.\\n     * @param authorized The authorized account address\\n     * @param permissions The new permissions will be added to the authorized account\\n     */\\n    function addPermissions(address authorized, Permission[] calldata permissions) external {\\n        if (authorized == address(0)) {\\n            revert AuthorizedAccountCannotBeZeroAddress();\\n        }\\n\\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[msg.sender];\\n        for (uint i; i < authAccounts.length; ++i) {\\n            if (authAccounts[i].account == authorized) {\\n                return _addPermissions(authorized, authAccounts[i], permissions);\\n            }\\n        }\\n\\n        revert AccountDoesNotExist();\\n    }\\n\\n    function _addPermissions(\\n        address authorized,\\n        AuthorizedAccount storage authAccount,\\n        Permission[] memory permissions\\n    ) private {\\n        for (uint i; i < permissions.length; ++i) {\\n            bool exists;\\n            for (uint j; j < authAccount.permissions.length; ++j) {\\n                AuthorizedPermission storage authPermission = authAccount.permissions[j];\\n                if (permissions[i] == authPermission.permission) {\\n                    exists = true;\\n                    authPermission.authorizedAt = block.number;\\n\\n                    // make sure unauthorizedAt is not greater than authorizedAt\\n                    // (refer to the comment in IAuthorizedAccount -> AuthorizedPermission struct)\\n                    if (authPermission.unauthorizedAt > authPermission.authorizedAt) {\\n                        authPermission.unauthorizedAt = authPermission.authorizedAt;\\n                    }\\n                    break;\\n                }\\n            }\\n            if (!exists) {\\n                authAccount.permissions.push(\\n                    AuthorizedPermission({\\n                        permission: permissions[i],\\n                        authorizedAt: block.number,\\n                        unauthorizedAt: 0\\n                    })\\n                );\\n            }\\n        }\\n\\n        emit PermissionsAdded(msg.sender, authorized, permissions);\\n    }\\n\\n    /**\\n     * @notice Removes permissions of specific authorized account.\\n     * - Removing permissions that don't exist in the Permission enum will return\\n     * with panic code 0x21 (convert a value that is too big or negative into an enum type).\\n     * - Removing duplicate/authorized permissions will update the permissions'\\n     * unauthorizedAt value.\\n     * This will revert if the account does not exist.\\n     * @param authorized The address of authorized account\\n     * @param permissions The list of permissions will be removed\\n     */\\n    function removePermissions(address authorized, Permission[] calldata permissions) external {\\n        if (authorized == address(0)) {\\n            revert AuthorizedAccountCannotBeZeroAddress();\\n        }\\n\\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[msg.sender];\\n        for (uint i; i < authAccounts.length; ++i) {\\n            if (authAccounts[i].account == authorized) {\\n                return _removePermissions(authorized, authAccounts[i], permissions);\\n            }\\n        }\\n\\n        revert AccountDoesNotExist();\\n    }\\n\\n    function _removePermissions(\\n        address authorized,\\n        AuthorizedAccount storage authAccount,\\n        Permission[] memory permissions\\n    ) private {\\n        for (uint i; i < permissions.length; ++i) {\\n            for (uint j; j < authAccount.permissions.length; ++j) {\\n                if (permissions[i] == authAccount.permissions[j].permission) {\\n                    // only update unauthorizedAt if the permission is authorized\\n                    if (\\n                        authAccount.permissions[j].authorizedAt >=\\n                        authAccount.permissions[j].unauthorizedAt\\n                    ) {\\n                        authAccount.permissions[j].unauthorizedAt = block.number + 1;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n\\n        emit PermissionsRemoved(msg.sender, authorized, permissions);\\n    }\\n\\n    /**\\n     * @notice Validates permission of an authorized account associated with the main account.\\n     *\\n     * @param main The address of main account\\n     * @param authorized The address of authorized account\\n     * @param permission The permission needs to be verified with the authorized account\\n     * @param atBlock The block number to check if the permission is valid between\\n     * the permission's authorizedAt and unauthorizedAt period. It is added later to prevent\\n     * the timing attack. E.g. If the main account authorizes the PersonalSign permission at\\n     * block 1, creates a ticket at block 2, then unauthorizes the permission at block 3, the\\n     * ticket will be invalid and cannot be redeemed. To avoid this, the `atBlock` param is\\n     * needed to check if the permission is authorized between its authorizedAt and unauthorizedAt\\n     * duration.\\n     *\\n     * @return boolean value\\n     */\\n    function validatePermission(\\n        address main,\\n        address authorized,\\n        Permission permission,\\n        uint256 atBlock\\n    ) external view returns (bool) {\\n        if (main == address(0)) {\\n            revert MainAccountCannotBeZeroAddress();\\n        }\\n\\n        if (authorized == address(0)) {\\n            revert AuthorizedAccountCannotBeZeroAddress();\\n        }\\n\\n        if (atBlock == 0) {\\n            revert AtBlockNumberCannotBeZero();\\n        }\\n\\n        AuthorizedAccount[] storage authAccounts = authorizedAccounts[main];\\n\\n        for (uint i = 0; i < authAccounts.length; ++i) {\\n            if (authAccounts[i].account == authorized) {\\n                for (uint j = 0; j < authAccounts[i].permissions.length; ++j) {\\n                    if (authAccounts[i].permissions[j].permission == permission) {\\n                        uint256 authorizedAt = authAccounts[i].permissions[j].authorizedAt;\\n                        uint256 unauthorizedAt = authAccounts[i].permissions[j].unauthorizedAt;\\n\\n                        bool isPermissionUnauthorized = authorizedAt > 0 &&\\n                            authorizedAt < unauthorizedAt;\\n                        if (isPermissionUnauthorized) {\\n                            // the permission was previously valid, so we check that\\n                            // the `atBlock` is referencing a time when the permission was valid\\n                            return authorizedAt <= atBlock && atBlock < unauthorizedAt;\\n                        }\\n\\n                        // otherwise just check if the permission was authorized before the\\n                        // atBlock\\n                        return authorizedAt > 0 && authorizedAt <= atBlock;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Get all authorized accounts associated with a given account\\n     * @param main The address of main account\\n     * @return An array of authorized accounts\\n     */\\n    function getAuthorizedAccounts(\\n        address main\\n    ) external view returns (AuthorizedAccount[] memory) {\\n        if (main == address(0)) {\\n            revert MainAccountCannotBeZeroAddress();\\n        }\\n\\n        return authorizedAccounts[main];\\n    }\\n\\n    function getAllPermissions() internal pure returns (Permission[] memory) {\\n        Permission[] memory permissions = new Permission[](1);\\n        permissions[0] = Permission.PersonalSign;\\n        return permissions;\\n    }\\n}\\n\",\"keccak256\":\"0x9e248094e7c8256f520ffa7eee09af4715fafa6fe94de35a8532752932fa0bdd\",\"license\":\"Apache-2.0\"},\"contracts/Registries.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\n\\nimport \\\"./libraries/SyloUtils.sol\\\";\\nimport \\\"./interfaces/IRegistries.sol\\\";\\n\\n/**\\n * @notice This contract manages Registries for Nodes. A Registry is a\\n * set of parameters configured by the Node itself. A Node is required\\n * to have a valid Registry to be able to participate in the network.\\n */\\ncontract Registries is IRegistries, Initializable, Ownable2StepUpgradeable, IERC165 {\\n    using ECDSA for bytes32;\\n\\n    /**\\n     * @notice ERC721 contract for bridged Seekers. Used for verifying ownership\\n     * of a seeker.\\n     */\\n    IERC721 public _rootSeekers;\\n\\n    /**\\n     * @notice Tracks each Node's registry.\\n     */\\n    mapping(address => IRegistries.Registry) public registries;\\n\\n    /**\\n     * @notice Tracks the node address that each seeker id is registered with\\n     */\\n    mapping(uint256 => address) public seekerRegistration;\\n\\n    /**\\n     * @notice Tracks the address of every registered node.\\n     */\\n    address[] public nodes;\\n\\n    /**\\n     * @notice Tracks nonces used when registering the seeker account\\n     * to prevent signature re-use.\\n     */\\n    mapping(bytes32 => address) private signatureNonces;\\n\\n    /**\\n     * @notice Payout percentage refers to the portion of a tickets reward\\n     * that will be allocated to the Node's stakers. This is global, and is\\n     * currently set for all Nodes.\\n     */\\n    uint32 public defaultPayoutPercentage;\\n\\n    event DefaultPayoutPercentageUpdated(uint32 defaultPayoutPercentage);\\n\\n    error NonceCannotBeReused();\\n    error EndMustBeGreaterThanStart();\\n    error PercentageCannotExceed100000();\\n    error PublicEndpointCannotBeEmpty();\\n    error SeekerAccountMustOwnSeekerId();\\n    error SeekerAccountMustBeMsgSender();\\n    error ProofNotSignedBySeekerAccount();\\n    error RootSeekersCannotBeZeroAddress();\\n    error SeekerAccountCannotBeZeroAddress();\\n    error EndCannotExceedNumberOfNodes(uint256 nodeLength);\\n\\n    function initialize(\\n        IERC721 rootSeekers,\\n        uint32 _defaultPayoutPercentage\\n    ) external initializer {\\n        if (address(rootSeekers) == address(0)) {\\n            revert RootSeekersCannotBeZeroAddress();\\n        }\\n        if (_defaultPayoutPercentage > 100000) {\\n            revert PercentageCannotExceed100000();\\n        }\\n\\n        Ownable2StepUpgradeable.__Ownable2Step_init();\\n\\n        _rootSeekers = rootSeekers;\\n        defaultPayoutPercentage = _defaultPayoutPercentage;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract implements the interface defined by\\n     * `interfaceId` from ERC165.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IRegistries).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Set the global default payout percentage value. Only callable\\n     * by the owner.\\n     * @param _defaultPayoutPercentage The payout percentage as a value where the\\n     * denominator is 10000.\\n     */\\n    function setDefaultPayoutPercentage(uint32 _defaultPayoutPercentage) external onlyOwner {\\n        if (_defaultPayoutPercentage > 100000) {\\n            revert PercentageCannotExceed100000();\\n        }\\n\\n        defaultPayoutPercentage = _defaultPayoutPercentage;\\n        emit DefaultPayoutPercentageUpdated(_defaultPayoutPercentage);\\n    }\\n\\n    /**\\n     * @notice Call this as a Node to set or update your Registry entry.\\n     * @param publicEndpoint The public endpoint of your Node. Essential for\\n     * clients to be able to retrieve additional information, such as\\n     * an address to establish a p2p connection.\\n     */\\n    function register(string calldata publicEndpoint) external {\\n        if (bytes(publicEndpoint).length == 0) {\\n            revert PublicEndpointCannotBeEmpty();\\n        }\\n\\n        // This is the nodes first registration\\n        if (bytes(registries[msg.sender].publicEndpoint).length == 0) {\\n            nodes.push(msg.sender);\\n        }\\n\\n        registries[msg.sender].publicEndpoint = publicEndpoint;\\n    }\\n\\n    function setSeekerAccount(\\n        address seekerAccount,\\n        uint256 seekerId,\\n        bytes32 nonce,\\n        bytes calldata signature\\n    ) external {\\n        if (seekerAccount == address(0)) {\\n            revert SeekerAccountCannotBeZeroAddress();\\n        }\\n        if (signatureNonces[nonce] != address(0)) {\\n            revert NonceCannotBeReused();\\n        }\\n\\n        bytes memory proofMessage = getProofMessage(seekerId, msg.sender, nonce);\\n        bytes32 ethProof = ECDSA.toEthSignedMessageHash(proofMessage);\\n\\n        if (ECDSA.recover(ethProof, signature) != seekerAccount) {\\n            revert ProofNotSignedBySeekerAccount();\\n        }\\n\\n        // Now verify the seeker account actually owns the seeker\\n        address owner = _rootSeekers.ownerOf(seekerId);\\n\\n        if (seekerAccount != owner) {\\n            revert SeekerAccountMustOwnSeekerId();\\n        }\\n\\n        delete registries[seekerRegistration[seekerId]].seekerId;\\n        delete registries[seekerRegistration[seekerId]].seekerAccount;\\n\\n        registries[msg.sender].seekerAccount = seekerAccount;\\n        registries[msg.sender].seekerId = seekerId;\\n\\n        seekerRegistration[seekerId] = msg.sender;\\n\\n        signatureNonces[nonce] = seekerAccount;\\n    }\\n\\n    function revokeSeekerAccount(address node) external {\\n        Registry storage registry = registries[node];\\n\\n        if (registry.seekerAccount != msg.sender) {\\n            revert SeekerAccountMustBeMsgSender();\\n        }\\n\\n        delete registry.seekerAccount;\\n        delete seekerRegistration[registry.seekerId];\\n        delete registry.seekerId;\\n    }\\n\\n    /**\\n     * @notice Retrieve the registry associated with a Node.\\n     * @param account The address of the Node.\\n     * @return The Node's Registry.\\n     */\\n    function getRegistry(address account) external view returns (Registry memory) {\\n        return registries[account];\\n    }\\n\\n    /**\\n     * @notice Retrieve all registered nodes.\\n     * @return An array of node addresses.\\n     */\\n    function getNodes() external view returns (address[] memory) {\\n        return nodes;\\n    }\\n\\n    /**\\n     * @notice Retrieves a list of registries. Takes in a\\n     * a start and end indices to allow pagination.\\n     * @param start The start index which is inclusive.\\n     * @param end The end index which is exclusive.\\n     * @return An array of Registries.\\n     */\\n    function getRegistries(\\n        uint256 start,\\n        uint256 end\\n    ) external view returns (address[] memory, Registry[] memory) {\\n        uint256 nodesLength = nodes.length;\\n\\n        if (end <= start) {\\n            revert EndMustBeGreaterThanStart();\\n        }\\n        if (end > nodesLength) {\\n            revert EndCannotExceedNumberOfNodes(nodesLength);\\n        }\\n\\n        address[] memory _nodes = new address[](end - start);\\n        Registry[] memory _registries = new Registry[](_nodes.length);\\n\\n        for (uint256 i = start; i < end; ++i) {\\n            _nodes[i - start] = nodes[i];\\n            _registries[i - start] = registries[nodes[i]];\\n        }\\n\\n        return (_nodes, _registries);\\n    }\\n\\n    /**\\n     * @notice Returns the total number of registered nodes.\\n     * @return The number of registered nodes.\\n     */\\n    function getTotalNodes() external view returns (uint256) {\\n        return nodes.length;\\n    }\\n\\n    /**\\n     * @notice Helper function for deriving the proof message used to\\n     * validate seeker ownership.\\n     * @param seekerId The tokenId of the seeker used for operation.\\n     * @param node The address of the node which that will be operated\\n     * by the specified seeker.\\n     * @param nonce The nonce used for this message.\\n     */\\n    function getProofMessage(\\n        uint256 seekerId,\\n        address node,\\n        bytes32 nonce\\n    ) public pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                unicode\\\"\\ud83e\\udd16 Hi frend! \\ud83e\\udd16\\\\n\\\\n\\ud83d\\udcdc Signing this message proves that you're the owner of this Seeker NFT and allows your Seeker to be used to operate your Seeker's Node. It's a simple but important step to ensure smooth operation.\\\\n\\\\nThis request will not trigger a blockchain transaction or cost any gas fees.\\\\n\\\\n\\ud83d\\udd25 Your node's address: \\\",\\n                Strings.toHexString(uint256(uint160(node)), 20),\\n                unicode\\\"\\\\n\\\\n\\ud83c\\udd94 Your seeker id: \\\",\\n                Strings.toString(seekerId),\\n                unicode\\\"\\\\n\\\\n\\ud83d\\udce6 A unique random value which secures this message: \\\",\\n                Strings.toHexString(uint256(nonce), 32)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x492be9b17a6624c5aa9de7b7d93f2ab1d7e6ee6443e60d4f036f7a7c670c343b\",\"license\":\"Apache-2.0\"},\"contracts/SeekerPowerOracle.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nimport \\\"./interfaces/ISeekerPowerOracle.sol\\\";\\n\\n/**\\n * @notice Acts as a source of information for Seeker Powers. Allows setting\\n * a Seeker's power level via a restricted oracle account call. Seeker Power can also\\n * be set by any account if the correct Oracle signature proof is provided.\\n */\\ncontract SeekerPowerOracle is ISeekerPowerOracle, Initializable, Ownable2StepUpgradeable, ERC165 {\\n    /**\\n     * @notice The oracle account. This contract accepts any attestations of\\n     * Seeker power that have been signed by this account.\\n     */\\n    address public oracle;\\n\\n    /**\\n     * @notice Tracks nonce used when register the Seeker power to\\n     * prevent signature re-use.\\n     */\\n    mapping(bytes32 => address) private proofNonces;\\n\\n    /**\\n     * @notice Tracks the set of Seeker Power levels.\\n     */\\n    mapping(uint256 => uint256) public seekerPowers;\\n\\n    event SeekerPowerUpdated(uint256 indexed seekerId, uint256 indexed power);\\n\\n    error UnauthorizedRegisterSeekerPowerCall();\\n    error NonceCannotBeReused();\\n\\n    function initialize(address _oracle) external initializer {\\n        Ownable2StepUpgradeable.__Ownable2Step_init();\\n\\n        oracle = _oracle;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract implements the interface defined by\\n     * `interfaceId` from ERC165.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(ISeekerPowerOracle).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Sets the oracle account.\\n     * @param _oracle The oracle account.\\n     */\\n    function setOracle(address _oracle) external onlyOwner {\\n        oracle = _oracle;\\n    }\\n\\n    /**\\n     * @notice Registers a Seeker's power level. Only callable by the\\n     * owner or the oracle account.\\n     * @param seekerId The id of the Seeker.\\n     * @param power The power level of the Seeker.\\n     */\\n    function registerSeekerPowerRestricted(uint256 seekerId, uint256 power) external {\\n        if (msg.sender != oracle) {\\n            revert UnauthorizedRegisterSeekerPowerCall();\\n        }\\n\\n        seekerPowers[seekerId] = power;\\n        emit SeekerPowerUpdated(seekerId, power);\\n    }\\n\\n    /**\\n     * @notice Registers a Seeker's power level. Callable by any account\\n     * but requires a proof signed by the oracle.\\n     * @param seekerId The id of the Seeker.\\n     * @param power The power level of the Seeker.\\n     */\\n    function registerSeekerPower(\\n        uint256 seekerId,\\n        uint256 power,\\n        bytes32 nonce,\\n        bytes calldata proof\\n    ) external {\\n        if (proofNonces[nonce] != address(0)) {\\n            revert NonceCannotBeReused();\\n        }\\n\\n        bytes memory proofMessage = getProofMessage(seekerId, power, nonce);\\n        bytes32 ecdsaHash = ECDSA.toEthSignedMessageHash(proofMessage);\\n\\n        if (ECDSA.recover(ecdsaHash, proof) != oracle) {\\n            revert UnauthorizedRegisterSeekerPowerCall();\\n        }\\n\\n        seekerPowers[seekerId] = power;\\n        proofNonces[nonce] = oracle;\\n\\n        emit SeekerPowerUpdated(seekerId, power);\\n    }\\n\\n    /**\\n     * @notice Retrieves a Seeker's stored power level.\\n     * @param seekerId The id of the Seeker.\\n     */\\n    function getSeekerPower(uint256 seekerId) external view returns (uint256) {\\n        return seekerPowers[seekerId];\\n    }\\n\\n    /**\\n     * @notice Constructs a proof message for the oracle to sign.\\n     * @param seekerId The id of the Seeker.\\n     * @param power The power level of the Seeker.\\n     */\\n    function getProofMessage(\\n        uint256 seekerId,\\n        uint256 power,\\n        bytes32 nonce\\n    ) public pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                Strings.toString(seekerId),\\n                \\\":\\\",\\n                Strings.toString(power),\\n                \\\":\\\",\\n                Strings.toHexString(uint256(nonce), 32)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xbd652d364b9b0742083dc6dcce34b58aefddda5335afdcb3f8d42358cb89b18a\",\"license\":\"Apache-2.0\"},\"contracts/SyloToken.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract SyloToken is ERC20 {\\n    constructor() ERC20(\\\"Sylo\\\", \\\"SYLO\\\") {\\n        _mint(msg.sender, 10_000_000_000 ether);\\n    }\\n}\\n\",\"keccak256\":\"0x75fda7d129e02669cd691691c14fccd1cdac23b833d7a25e899801865d58ef26\",\"license\":\"Apache-2.0\"},\"contracts/epochs/EpochsManager.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"../Registries.sol\\\";\\nimport \\\"../staking/Directory.sol\\\";\\nimport \\\"../interfaces/epochs/IEpochsManager.sol\\\";\\nimport \\\"../payments/ticketing/TicketingParameters.sol\\\";\\n\\ncontract EpochsManager is IEpochsManager, Initializable, Ownable2StepUpgradeable, ERC165 {\\n    Directory public _directory;\\n\\n    Registries public _registries;\\n\\n    IERC721 public _rootSeekers;\\n\\n    TicketingParameters public _ticketingParameters;\\n\\n    /**\\n     * @notice Track seekers that have joined for a specific epoch.\\n     */\\n    mapping(uint256 => mapping(uint256 => address)) public activeSeekers;\\n\\n    // Define all Epoch specific parameters here.\\n    // When initializing an epoch, these parameters are read,\\n    // along with parameters from the other contracts to create the\\n    // new epoch.\\n\\n    /**\\n     * @notice A mapping of all epochs that have been initialized.\\n     */\\n    mapping(uint256 => Epoch) public epochs;\\n\\n    /**\\n     * @notice The block number since the first epoch can be initialized.\\n     */\\n    uint256 public initialEpoch;\\n\\n    /**\\n     * @notice The duration in blocks an epoch will last for.\\n     */\\n    uint256 public epochDuration;\\n\\n    /**\\n     * @notice The value of the integer used as the current\\n     * epoch's identifier. This value is incremented as each epoch\\n     * is initialized.\\n     */\\n    uint256 public currentIteration;\\n\\n    event NewEpoch(uint256 indexed epochId);\\n    event EpochJoined(uint256 indexed epochId, address indexed node, uint256 indexed seekerId);\\n    event InitialEpochUpdated(uint256 initialEpoch);\\n    event EpochDurationUpdated(uint256 epochDuration);\\n\\n    error SeekerOwnerMismatch();\\n    error InitialEpochCannotBeZero();\\n    error EpochDurationCannotBeZero();\\n    error DirectoryCannotBeZeroAddress();\\n    error RegistriesCannotBeZeroAddress();\\n    error RootSeekerCannotBeZeroAddress();\\n    error EpochHasNotEnded(uint256 epochId);\\n    error SeekerAccountCannotBeZeroAddress();\\n    error TicketingParametersCannotBeZeroAddress();\\n    error SeekerAlreadyJoinedEpoch(uint256 epochId, uint256 seekerId);\\n    error InitialEpochNotYetReady(uint256 expectedBlock, uint256 currentBlock);\\n\\n    function initialize(\\n        IERC721 rootSeekers,\\n        Directory directory,\\n        Registries registries,\\n        TicketingParameters ticketingParameters,\\n        uint256 _initialEpoch,\\n        uint256 _epochDuration\\n    ) external initializer {\\n        if (address(rootSeekers) == address(0)) {\\n            revert RootSeekerCannotBeZeroAddress();\\n        }\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"Directory\\\",\\n            address(directory),\\n            type(IDirectory).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"Registries\\\",\\n            address(registries),\\n            type(IRegistries).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"TicketingParameters\\\",\\n            address(ticketingParameters),\\n            type(ITicketingParameters).interfaceId\\n        );\\n\\n        Ownable2StepUpgradeable.__Ownable2Step_init();\\n\\n        _rootSeekers = rootSeekers;\\n        _directory = directory;\\n        _registries = registries;\\n        _ticketingParameters = ticketingParameters;\\n\\n        initialEpoch = _initialEpoch;\\n        epochDuration = _epochDuration;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract implements the interface defined by\\n     * `interfaceId` from ERC165.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IEpochsManager).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Call this to initialize the next epoch. On success, a `NewEpoch` event\\n     * will be emitted.\\n     * @dev The function will read the current set of network parameters, and store\\n     * the parameters in a new Epoch struct. The end block of the current epoch\\n     * will also be set to a non-zero value.\\n     */\\n    function initializeEpoch() external returns (uint256) {\\n        if (currentIteration == 0 && initialEpoch > block.number) {\\n            revert InitialEpochNotYetReady(initialEpoch, block.number);\\n        }\\n\\n        Epoch storage current = epochs[currentIteration];\\n\\n        uint256 end = current.startBlock + current.duration;\\n        if (end > block.number) {\\n            revert EpochHasNotEnded(currentIteration);\\n        }\\n\\n        (\\n            uint256 faceValue,\\n            uint128 baseLiveWinProb,\\n            uint128 expiredWinProb,\\n            uint256 ticketDuration,\\n            uint32 decayRate\\n        ) = _ticketingParameters.getTicketingParameters();\\n\\n        uint256 nextEpochId = getNextEpochId();\\n\\n        epochs[nextEpochId] = Epoch(\\n            block.number,\\n            epochDuration,\\n            0,\\n            _registries.defaultPayoutPercentage(),\\n            decayRate,\\n            faceValue,\\n            baseLiveWinProb,\\n            expiredWinProb,\\n            ticketDuration\\n        );\\n\\n        current.endBlock = block.number;\\n\\n        currentIteration = nextEpochId;\\n\\n        _directory.setCurrentDirectory(nextEpochId);\\n\\n        emit NewEpoch(nextEpochId);\\n\\n        return nextEpochId;\\n    }\\n\\n    /**\\n     * @notice Set the first epoch starting block. Only callable by the owner.\\n     * @param _initialEpoch The block number when the first epoch can be initialized.\\n     */\\n    function setInitialEpoch(uint256 _initialEpoch) external onlyOwner {\\n        if (_initialEpoch == 0) {\\n            revert InitialEpochCannotBeZero();\\n        }\\n        initialEpoch = _initialEpoch;\\n        emit InitialEpochUpdated(_initialEpoch);\\n    }\\n\\n    /**\\n     * @notice Set the epoch duration. Will take effect in the next epoch. Only\\n     * callable by the owner.\\n     * @param _epochDuration The epoch duration in number of blocks.\\n     */\\n    function setEpochDuration(uint256 _epochDuration) external onlyOwner {\\n        if (_epochDuration == 0) {\\n            revert EpochDurationCannotBeZero();\\n        }\\n        epochDuration = _epochDuration;\\n        emit EpochDurationUpdated(epochDuration);\\n    }\\n\\n    /**\\n     * @notice Retrieve the parameters for the current epoch.\\n     * @return The current Epoch parameters.\\n     */\\n    function getCurrentActiveEpoch() external view returns (uint256, Epoch memory) {\\n        return (currentIteration, epochs[currentIteration]);\\n    }\\n\\n    /**\\n     * @notice Nodes should call this to join the next epoch. It will\\n     * initialize the next reward pool and set the stake for the next directory.\\n     * @dev This is a proxy function for `initalizeNextRewardPool` and\\n     * `joinNextDirectory`.\\n     */\\n    function joinNextEpoch() external {\\n        Registries.Registry memory registry = _registries.getRegistry(msg.sender);\\n\\n        // validate the node's seeker ownership\\n        if (registry.seekerAccount == address(0)) {\\n            revert SeekerAccountCannotBeZeroAddress();\\n        }\\n\\n        uint256 seekerId = registry.seekerId;\\n\\n        address owner = _rootSeekers.ownerOf(seekerId);\\n        if (registry.seekerAccount != owner) {\\n            revert SeekerOwnerMismatch();\\n        }\\n\\n        uint256 nextEpoch = getNextEpochId();\\n        if (activeSeekers[nextEpoch][seekerId] != address(0)) {\\n            revert SeekerAlreadyJoinedEpoch(nextEpoch, seekerId);\\n        }\\n\\n        activeSeekers[nextEpoch][seekerId] = msg.sender;\\n\\n        _directory._rewardsManager().initializeNextRewardPool(msg.sender);\\n        _directory.joinNextDirectory(msg.sender, seekerId);\\n\\n        emit EpochJoined(nextEpoch, msg.sender, seekerId);\\n    }\\n\\n    /**\\n     * @notice Retrieve the epoch parameter for the given id.\\n     * @param epochId The id of the epoch to retrieve.\\n     * @return The epoch parameters associated with the id.\\n     */\\n    function getEpoch(uint256 epochId) external view returns (Epoch memory) {\\n        return epochs[epochId];\\n    }\\n\\n    /**\\n     * @notice Retrieve the integer value that will be used for the\\n     * next epoch id.\\n     * @return The next epoch id identifier.\\n     */\\n    function getNextEpochId() public view returns (uint256) {\\n        return currentIteration + 1;\\n    }\\n}\\n\",\"keccak256\":\"0xc759afdc6022b1490447d2c3c3b4454c59cc86f59fe62cece92764b787a87030\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IAuthorizedAccounts.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface IAuthorizedAccounts {\\n    enum Permission {\\n        // PersonalSign permission allows the authorized account to\\n        // sign on behalf of the sending account.\\n        PersonalSign\\n    }\\n\\n    /**\\n     * @dev This type will hold the permission type and the block number from\\n     * which the permission was set to be authorized and unauthorized.\\n     * The permission is authorized when authorizedAt >= unauthorizedAt.\\n     *\\n     * Note: authorizedAt and unauthorizedAt won't be set to 0 when the permission\\n     * is updated, because they are both needed when validating the permission.\\n     */\\n    struct AuthorizedPermission {\\n        // Permission type\\n        Permission permission;\\n        // Block number from which the permission was set to be authorized.\\n        // If the transaction is called in block 1, the permission is\\n        // authorized from block 1 (authorizedAt = block.number).\\n        uint256 authorizedAt;\\n        // Block number from which the permission was set to be unauthorized.\\n        // If the transaction is called in block 1, the permission is\\n        // unauthorized from block 2 (unauthorizedAt = block.number + 1)\\n        // unauthorizedAt is set that way to avoid the case where the\\n        // permission is authorized and unauthorized in the same block:\\n        // E.g. addPermission is called => authorizedAt = 1\\n        //      removePermission is called => unauthorizedAt = 1\\n        // => We cannot tell if the permission is authorized or not.\\n        // E.g. addPermission is called => authorizedAt = 1\\n        //      removePermission is called => unauthorizedAt = 2\\n        //      addPermission is called => authorizedAt = 1 AND update unauthorizedAt = authorizedAt = 1\\n        // => The permission is authorized when authorizedAt >= unauthorizedAt\\n        uint256 unauthorizedAt;\\n    }\\n\\n    struct AuthorizedAccount {\\n        // The authorized account\\n        address account;\\n        // Block number at which the account was authorized.\\n        // If the transaction is called in block 1, the account is\\n        // authorized at block 1 (authorizedAt = block.number).\\n        // If the account is unauthorized, authorizedAt will be set to 0.\\n        uint256 authorizedAt;\\n        // Permission list\\n        AuthorizedPermission[] permissions;\\n    }\\n\\n    function authorizeAccount(address authorized, Permission[] calldata permissions) external;\\n\\n    function unauthorizeAccount(address authorized) external;\\n\\n    function addPermissions(address authorized, Permission[] calldata permissions) external;\\n\\n    function removePermissions(\\n        address authorized,\\n        Permission[] calldata permissionsToRemove\\n    ) external;\\n\\n    function validatePermission(\\n        address main,\\n        address authorized,\\n        Permission permission,\\n        uint256 atBlock\\n    ) external returns (bool);\\n\\n    function getAuthorizedAccounts(\\n        address main\\n    ) external view returns (AuthorizedAccount[] memory);\\n}\\n\",\"keccak256\":\"0xebc98a4d5ed21face8bf0ef8ba07693b82ca89c81d52eb4f2adc5e99c94d7b30\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IFuturePassRegistrar.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface IFuturePassRegistrar {\\n    function futurepassOf(address owner) external view returns (address);\\n\\n    function create(address owner) external returns (address);\\n}\\n\",\"keccak256\":\"0x6f671c6d5d9e078eadea1b38ab2b05ca5b565cb8484fd1d6b46247505285c91f\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IRegistries.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface IRegistries {\\n    struct Registry {\\n        // Percentage of a tickets value that will be rewarded to\\n        // delegated stakers expressed as a fraction of 100000.\\n        // This value is currently locked to the default payout percentage\\n        // until epochs are implemented.\\n        uint32 payoutPercentage;\\n        // Public http/s endpoint to retrieve additional metadata\\n        // about the node.\\n        // The current metadata schema is as follows:\\n        //  { name: string, multiaddrs: string[] }\\n        string publicEndpoint;\\n        // The account which owns a seeker that will be used to\\n        // operate the Node for this registry.\\n        address seekerAccount;\\n        // The id of the seeker used to operate the node. The owner\\n        // of this id should be the seeker account.\\n        uint256 seekerId;\\n    }\\n\\n    function register(string calldata publicEndpoint) external;\\n\\n    function setDefaultPayoutPercentage(uint32 _defaultPayoutPercentage) external;\\n\\n    function setSeekerAccount(\\n        address seekerAccount,\\n        uint256 seekerId,\\n        bytes32 nonce,\\n        bytes calldata signature\\n    ) external;\\n\\n    function revokeSeekerAccount(address node) external;\\n\\n    function getRegistry(address account) external view returns (Registry memory);\\n\\n    function getNodes() external view returns (address[] memory);\\n\\n    function getRegistries(\\n        uint256 start,\\n        uint256 end\\n    ) external view returns (address[] memory, Registry[] memory);\\n\\n    function getTotalNodes() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x524252752fd14eb66b047848eaaffbc138c6b049f99f2c2f0a5c6a7a4d6e6e36\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/ISeekerPowerOracle.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface ISeekerPowerOracle {\\n    function setOracle(address oracle) external;\\n\\n    function registerSeekerPowerRestricted(uint256 seekerId, uint256 power) external;\\n\\n    function registerSeekerPower(\\n        uint256 seekerId,\\n        uint256 power,\\n        bytes32 nonce,\\n        bytes calldata proof\\n    ) external;\\n\\n    function getSeekerPower(uint256 seekerId) external view returns (uint256);\\n\\n    function getProofMessage(\\n        uint256 seekerId,\\n        uint256 power,\\n        bytes32 nonce\\n    ) external pure returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x26fb3e81dabde31b8730d4c601c51c881e018b540f19f7c599a8a7f9b8c05523\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/epochs/IEpochsManager.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface IEpochsManager {\\n    /**\\n     * @dev This struct will hold all network parameters that will be static\\n     * for the entire epoch. This value will be stored in a mapping, where the\\n     * key is the current epoch id.\\n     */\\n    struct Epoch {\\n        // time related variables\\n        uint256 startBlock; // Block the epoch was initialized\\n        uint256 duration; // Minimum time epoch will be alive measured in number of blocks\\n        uint256 endBlock; // Block the epoch ended (and when the next epoch was initialized)\\n        // Zero here represents the epoch has not yet ended.\\n\\n        // registry variables\\n        uint32 defaultPayoutPercentage;\\n        // ticketing variables\\n        uint32 decayRate;\\n        uint256 faceValue;\\n        uint128 baseLiveWinProb;\\n        uint128 expiredWinProb;\\n        uint256 ticketDuration;\\n    }\\n\\n    function initializeEpoch() external returns (uint256);\\n\\n    function setEpochDuration(uint256 _epochDuration) external;\\n\\n    function getCurrentActiveEpoch() external view returns (uint256, Epoch memory);\\n\\n    function joinNextEpoch() external;\\n\\n    function getEpoch(uint256 epochId) external view returns (Epoch memory);\\n\\n    function getNextEpochId() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xeef359833a448742f4eca45ac04eeea0c3e74eb21d3a36bfdae3a1bb7f81e0b5\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/payments/ISyloTicketing.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface ISyloTicketing {\\n    struct Deposit {\\n        uint256 escrow; // Balance of users escrow\\n        uint256 penalty; // Balance of users penalty\\n        uint256 unlockAt; // Block number a user can withdraw their balances\\n    }\\n\\n    struct User {\\n        address main; // Main address of the ticket sender or receiver\\n        address delegated; // Delegated address used to sign and redeem tickets\\n    }\\n\\n    struct Ticket {\\n        uint256 epochId; // The epoch this ticket is associated with\\n        User sender; // Ticket sender's main and delegated addresses\\n        User receiver; // Ticket receiver's main and delegated addresses\\n        address redeemer; // Address of the intended recipient\\n        uint256 generationBlock; // Block number the ticket was generated\\n        bytes32 redeemerCommit; // Hash of the secret random number of the redeemer\\n    }\\n\\n    // A type of ticket that does not explicit state the receiver address.\\n    struct MultiReceiverTicket {\\n        uint256 epochId; // The epoch this ticket is associated with\\n        User sender; // Ticket sender's main and delegated addresses\\n        address redeemer; // Address of the intended recipient\\n        uint256 generationBlock; // Block number the ticket was generated\\n        bytes32 redeemerCommit; // Hash of the secret random number of the redeemer\\n    }\\n\\n    function setUnlockDuration(uint256 _unlockDuration) external;\\n\\n    function depositEscrow(uint256 amount, address account) external;\\n\\n    function depositPenalty(uint256 amount, address account) external;\\n\\n    function unlockDeposits() external returns (uint256);\\n\\n    function lockDeposits() external;\\n\\n    function withdraw() external;\\n\\n    function redeem(\\n        Ticket calldata ticket,\\n        uint256 redeemerRand,\\n        bytes calldata senderSig,\\n        bytes calldata receiverSig\\n    ) external;\\n\\n    function redeemMultiReceiver(\\n        MultiReceiverTicket calldata ticket,\\n        uint256 redeemerRand,\\n        User calldata receiver,\\n        bytes calldata senderSig,\\n        bytes calldata receiverSig\\n    ) external;\\n}\\n\",\"keccak256\":\"0xb700a2d362f6a52195adf5c6e32668cbe0023aca2fa3e2562ebb94fa9c1ac0e0\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/payments/ticketing/IRewardsManager.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface IRewardsManager {\\n    /**\\n     * @dev This type will hold the necessary information for delegated stakers\\n     * to make reward claims against their Node. Every Node will initialize\\n     * and store a new Reward Pool for each epoch they participate in.\\n     */\\n    struct RewardPool {\\n        // Tracks the balance of the reward pool owed to the stakers\\n        uint256 stakersRewardTotal;\\n        // Tracks the block number this reward pool was initialized\\n        uint256 initializedAt;\\n        // The total active stake for the node for will be the sum of the\\n        // stakes owned by its delegators and the node's own stake.\\n        uint256 totalActiveStake;\\n        // track the cumulative reward factor as of the time the first ticket\\n        // for this pool was redeemed\\n        int128 initialCumulativeRewardFactor;\\n    }\\n\\n    struct LastClaim {\\n        // The epoch the claim was made.\\n        uint256 claimedAt;\\n        // The stake at the time the claim was made. This is tracked as\\n        // rewards can only be claimed after an epoch has ended, but the\\n        // user's stake may have changed by then. This field tracks the\\n        // staking value before the change so the reward for that epoch\\n        // can be manually calculated.\\n        uint256 stake;\\n    }\\n\\n    function getRewardPool(\\n        uint256 epochId,\\n        address stakee\\n    ) external view returns (RewardPool memory);\\n\\n    function getRewardPoolKey(uint256 epochId, address stakee) external pure returns (bytes32);\\n\\n    function getRewardPoolStakersTotal(\\n        uint256 epochId,\\n        address stakee\\n    ) external view returns (uint256);\\n\\n    function getRewardPoolActiveStake(\\n        uint256 epochId,\\n        address stakee\\n    ) external view returns (uint256);\\n\\n    function getPendingRewards(address stakee) external view returns (uint256);\\n\\n    function getLastClaim(address stakee, address staker) external view returns (LastClaim memory);\\n\\n    function getTotalEpochRewards(uint256 epochId) external view returns (uint256);\\n\\n    function getTotalEpochStakingRewards(uint256 epochId) external view returns (uint256);\\n\\n    function initializeNextRewardPool(address stakee) external;\\n\\n    function incrementRewardPool(address stakee, uint256 amount) external;\\n\\n    function claimStakingRewards(address stakee) external returns (uint256);\\n\\n    function updatePendingRewards(address stakee, address staker) external;\\n}\\n\",\"keccak256\":\"0x21b8d7f96073802ef4ec87fa15da5fcfd2c1d5e2bf9d6e17583406028e7b31d1\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/payments/ticketing/ITicketingParameters.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface ITicketingParameters {\\n    function setFaceValue(uint256 _faceValue) external;\\n\\n    function setBaseLiveWinProb(uint128 _baseLiveWinProb) external;\\n\\n    function setExpiredWinProb(uint128 _expiredWinProb) external;\\n\\n    function setDecayRate(uint32 _decayRate) external;\\n\\n    function setTicketDuration(uint256 _ticketDuration) external;\\n\\n    function getTicketingParameters()\\n        external\\n        view\\n        returns (uint256, uint128, uint128, uint256, uint32);\\n}\\n\",\"keccak256\":\"0x6fa269d73176bd6543c190b070597fde50b91efdaa724b567bad29c9fbfa908a\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/staking/IDirectory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface IDirectory {\\n    /**\\n     * @dev A DirectoryEntry will be stored for every node that joins the\\n     * network in a specific epoch. The entry will contain the stakee's\\n     * address, and a boundary value which is a sum of the current directory's\\n     * total stake, and the current stakee's total stake.\\n     */\\n    struct DirectoryEntry {\\n        address stakee;\\n        uint256 boundary;\\n    }\\n\\n    /**\\n     * @dev An EpochDirectory will be stored for every epoch. The\\n     * directory will be constructed piece by piece as Nodes join,\\n     * each adding their own directory entry based on their current\\n     * stake value.\\n     */\\n    struct EpochDirectory {\\n        DirectoryEntry[] entries;\\n        mapping(address => uint256) stakes;\\n        uint256 totalStake;\\n    }\\n\\n    function setCurrentDirectory(uint256 epochId) external;\\n\\n    function joinNextDirectory(address stakee, uint256 seekerId) external;\\n\\n    function scan(uint128 point) external view returns (address stakee);\\n\\n    function scanWithEpochId(\\n        uint128 point,\\n        uint256 epochId\\n    ) external view returns (address stakee);\\n\\n    function getTotalStakeForStakee(\\n        uint256 epochId,\\n        address stakee\\n    ) external view returns (uint256);\\n\\n    function getTotalStake(uint256 epochId) external view returns (uint256);\\n\\n    function getEntries(\\n        uint256 epochId\\n    ) external view returns (address[] memory, uint256[] memory);\\n}\\n\",\"keccak256\":\"0xfacfde1140082a99e6096222a0714bf9e532224a04c594096211c115ab4927f6\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/staking/IStakingManager.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\ninterface IStakingManager {\\n    /**\\n     * For every Node, there will be a mapping of the staker to a\\n     * StakeEntry. The stake entry tracks the amount of stake in SOLO,\\n     * and also when the stake was updated.\\n     */\\n    struct StakeEntry {\\n        uint256 amount;\\n        // Block number this entry was updated at\\n        uint256 updatedAt;\\n        // Epoch this entry was updated. The stake will become active\\n        // in the following epoch\\n        uint256 epochId;\\n    }\\n\\n    /**\\n     * Every Node must have stake in order to participate in the Epoch.\\n     * Stake can be provided by the Node itself or by other accounts in\\n     * the network.\\n     */\\n    struct Stake {\\n        // Track each stake entry associated to a node\\n        mapping(address => StakeEntry) stakeEntries;\\n        // The total stake held by this contract for a node,\\n        // which will be the sum of all addStake and unlockStake calls\\n        uint256 totalManagedStake;\\n    }\\n\\n    /**\\n     * This struct will track stake that is in the process of unlocking.\\n     */\\n    struct Unlock {\\n        uint256 amount; // Amount of stake unlocking\\n        uint256 unlockAt; // Block number the stake becomes withdrawable\\n    }\\n\\n    function setUnlockDuration(uint256 _unlockDuration) external;\\n\\n    function setMinimumStakeProportion(uint32 _minimumStakeProportion) external;\\n\\n    function addStake(uint256 amount, address stakee) external;\\n\\n    function unlockStake(uint256 amount, address stakee) external returns (uint256);\\n\\n    function withdrawStake(address stakee) external;\\n\\n    function cancelUnlocking(uint256 amount, address stakee) external;\\n\\n    function calculateCapacityFromSeekerPower(uint256 seekerId) external view returns (uint256);\\n\\n    function calculateMaxAdditionalDelegatedStake(address stakee) external view returns (uint256);\\n\\n    function getTotalManagedStake() external view returns (uint256);\\n\\n    function getStakeEntry(\\n        address stakee,\\n        address staker\\n    ) external view returns (StakeEntry memory);\\n\\n    function getStakeeTotalManagedStake(address stakee) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb3c89c77822db30a1382ec7d11902db579cd48acc36aef965a92b47f8e1164a3\",\"license\":\"Apache-2.0\"},\"contracts/libraries/Manageable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an list of public managers who may be added or removed.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyManager`, which can be applied to your functions to restrict their use to\\n * other contracts which have explicitly been added.\\n */\\nabstract contract Manageable is Ownable2StepUpgradeable {\\n    /**\\n     * @dev Tracks the managers added to this contract, where they key is the\\n     * address of the managing contract, and the value is the block the manager was added in.\\n     * We use this mapping to restrict access to those functions in a similar\\n     * fashion to the onlyOwner construct.\\n     */\\n    mapping(address => uint256) public managers;\\n\\n    error OnlyManagers();\\n    error ManagerCannotBeZeroAddress();\\n\\n    /**\\n     * @notice Adds a manager to this contract. Only callable by the owner.\\n     * @param manager The address of the manager contract.\\n     */\\n    function addManager(address manager) external onlyOwner {\\n        if (manager == address(0)) {\\n            revert ManagerCannotBeZeroAddress();\\n        }\\n        managers[manager] = block.number;\\n    }\\n\\n    /**\\n     * @notice Removes a manager from this contract. Only callable by the owner.\\n     * @param manager The address of the manager contract.\\n     */\\n    function removeManager(address manager) external onlyOwner {\\n        delete managers[manager];\\n    }\\n\\n    /**\\n     * @dev This modifier allows us to specify that certain contracts have\\n     * special privileges to call restricted functions.\\n     */\\n    modifier onlyManager() {\\n        if (managers[msg.sender] == 0) {\\n            revert OnlyManagers();\\n        }\\n        _;\\n    }\\n\\n    // Reserve storage slots for future variables\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xeaf4d3bf238df7e61eaf6903ba7ed54af58a17090fe6197aae3f62d025027db2\",\"license\":\"Apache-2.0\"},\"contracts/libraries/SyloUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nerror ContractNameCannotBeEmpty();\\nerror InterfaceIdCannotBeZeroBytes();\\nerror TargetContractCannotBeZeroAddress(string name);\\nerror TargetNotSupportInterface(string name, bytes4 interfaceId);\\n\\nlibrary SyloUtils {\\n    /**\\n     * @dev The maximum possible SYLO that exists in the network.\\n     */\\n    uint256 public constant MAX_SYLO = 10_000_000_000 ether;\\n\\n    /**\\n     * @dev Percentages are expressed as a ratio where 100000 is the denominator.\\n     * A large denominator allows for more precision, e.g representing 12.5%\\n     * can be done as 12500 / 100000\\n     */\\n    uint32 public constant PERCENTAGE_DENOMINATOR = 100000;\\n\\n    /**\\n     * @dev Multiply a value by a given percentage. Converts the provided\\n     * uint128 value to uint256 to avoid any reverts on overflow.\\n     * @param value The value to multiply.\\n     * @param percentage The percentage, as a ratio of 10000.\\n     */\\n    function percOf(uint128 value, uint32 percentage) internal pure returns (uint256) {\\n        return (uint256(value) * percentage) / PERCENTAGE_DENOMINATOR;\\n    }\\n\\n    /**\\n     * @dev Return a fraction as a percentage.\\n     * @param numerator The numerator limited to a uint128 value to prevent\\n     * phantom overflow.\\n     * @param denominator The denominator.\\n     * @return The percentage, as a ratio of 10000.\\n     */\\n    function asPerc(uint128 numerator, uint256 denominator) internal pure returns (uint32) {\\n        return SafeCast.toUint32((uint256(numerator) * PERCENTAGE_DENOMINATOR) / denominator);\\n    }\\n\\n    /**\\n     * @dev Validate that a contract implements a given interface.\\n     * @param name The name of the contract, used in error messages.\\n     * @param target The address of the contract.\\n     * @param interfaceId The interface ID to check.\\n     */\\n    function validateContractInterface(\\n        string memory name,\\n        address target,\\n        bytes4 interfaceId\\n    ) internal view {\\n        if (bytes(name).length == 0) {\\n            revert ContractNameCannotBeEmpty();\\n        }\\n        if (target == address(0)) {\\n            revert TargetContractCannotBeZeroAddress(name);\\n        }\\n        if (interfaceId == bytes4(0)) {\\n            revert InterfaceIdCannotBeZeroBytes();\\n        }\\n        if (!ERC165(target).supportsInterface(interfaceId)) {\\n            revert TargetNotSupportInterface(name, interfaceId);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa5bb1a5b9f8135b5fec1dfa183fab8f6685a4eb6d9daba23864a7d49d01dc8a3\",\"license\":\"Apache-2.0\"},\"contracts/payments/SyloTicketing.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"../Registries.sol\\\";\\nimport \\\"../staking/Directory.sol\\\";\\nimport \\\"../libraries/SyloUtils.sol\\\";\\nimport \\\"../epochs/EpochsManager.sol\\\";\\nimport \\\"../staking/StakingManager.sol\\\";\\nimport \\\"./ticketing/RewardsManager.sol\\\";\\nimport \\\"../AuthorizedAccounts.sol\\\";\\nimport \\\"../interfaces/payments/ISyloTicketing.sol\\\";\\nimport \\\"../interfaces/IFuturePassRegistrar.sol\\\";\\n\\n/**\\n * @notice The SyloTicketing contract manages the Probabilistic\\n * Micro-Payment Ticketing system that pays Nodes for providing the\\n * Event Relay service.\\n */\\ncontract SyloTicketing is ISyloTicketing, Initializable, Ownable2StepUpgradeable, ERC165 {\\n    /** ERC20 Sylo token contract.*/\\n    IERC20 public _token;\\n\\n    /** Sylo Registries contract */\\n    Registries public _registries;\\n\\n    /** Sylo Staking Manager contract */\\n    StakingManager public _stakingManager;\\n\\n    /** Sylo Directory contract */\\n    Directory public _directory;\\n\\n    /** Rewards Manager contract */\\n    RewardsManager public _rewardsManager;\\n\\n    /**\\n     * @notice Sylo Epochs Manager.\\n     * @dev The ticketing parameters used when redeeming tickets\\n     * will be read from this contract.\\n     */\\n    EpochsManager public _epochsManager;\\n\\n    /**\\n     * @notice Sylo Authorized Accounts.\\n     */\\n    AuthorizedAccounts public _authorizedAccounts;\\n\\n    /**\\n     * @notice Futurepass Registrar Pre-compile.\\n     */\\n    IFuturePassRegistrar public _futurepassRegistrar;\\n\\n    /**\\n     * @notice The number of blocks a user must wait after calling \\\"unlock\\\"\\n     * before they can withdraw their funds.\\n     */\\n    uint256 public unlockDuration;\\n\\n    /** @notice Mapping of user deposits */\\n    mapping(address => Deposit) public deposits;\\n\\n    /** @notice Mapping of ticket hashes, used to check if a ticket has been redeemed */\\n    mapping(bytes32 => bool) public usedTickets;\\n\\n    event UnlockDurationUpdated(uint256 unlockDuration);\\n    event SenderPenaltyBurnt(address sender);\\n    event Redemption(\\n        uint256 indexed epochId,\\n        address indexed redeemer,\\n        address indexed sender,\\n        address receiver,\\n        uint256 generationBlock,\\n        uint256 amount\\n    );\\n    event MultiReceiverRedemption(\\n        uint256 indexed epochId,\\n        address indexed redeemer,\\n        address indexed sender,\\n        address receiver,\\n        uint256 generationBlock,\\n        uint256 amount\\n    );\\n\\n    error NoEsrowAndPenalty();\\n    error UnlockingInProcess();\\n    error UnlockingNotInProcess();\\n    error UnlockingNotCompleted();\\n    error EscrowAmountCannotBeZero();\\n    error PenaltyAmountCannotBeZero();\\n    error UnlockDurationCannotBeZero();\\n    error AccountCannotBeZeroAddress();\\n    error InvalidSenderSigningPermission();\\n    error InvalidReceiverSigningPermission();\\n\\n    error TicketNotWinning();\\n    error MissingFuturepassAccount(address receiver);\\n    error TicketAlreadyUsed();\\n    error TicketEpochNotFound();\\n    error TicketAlreadyRedeemed();\\n    error RedeemerCommitMismatch();\\n    error InvalidSenderSignature();\\n    error InvalidReceiverSignature();\\n    error TokenCannotBeZeroAddress();\\n    error TicketNotCreatedInTheEpoch();\\n    error TicketCannotBeFromFutureBlock();\\n    error TicketSenderCannotBeZeroAddress();\\n    error TicketReceiverCannotBeZeroAddress();\\n    error TicketRedeemerCannotBeZeroAddress();\\n    error RedeemerMustHaveJoinedEpoch(uint256 epochId);\\n\\n    function initialize(\\n        IERC20 token,\\n        Registries registries,\\n        StakingManager stakingManager,\\n        Directory directory,\\n        EpochsManager epochsManager,\\n        RewardsManager rewardsManager,\\n        AuthorizedAccounts authorizedAccounts,\\n        IFuturePassRegistrar futurepassRegistrar,\\n        uint256 _unlockDuration\\n    ) external initializer {\\n        if (address(token) == address(0)) {\\n            revert TokenCannotBeZeroAddress();\\n        }\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"Registries\\\",\\n            address(registries),\\n            type(IRegistries).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"StakingManager\\\",\\n            address(stakingManager),\\n            type(IStakingManager).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"Directory\\\",\\n            address(directory),\\n            type(IDirectory).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"EpochsManager\\\",\\n            address(epochsManager),\\n            type(IEpochsManager).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"RewardsManager\\\",\\n            address(rewardsManager),\\n            type(IRewardsManager).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"AuthorizedAccounts\\\",\\n            address(authorizedAccounts),\\n            type(IAuthorizedAccounts).interfaceId\\n        );\\n\\n        if (_unlockDuration == 0) {\\n            revert UnlockDurationCannotBeZero();\\n        }\\n\\n        Ownable2StepUpgradeable.__Ownable2Step_init();\\n\\n        _token = token;\\n        _registries = registries;\\n        _stakingManager = stakingManager;\\n        _directory = directory;\\n        _epochsManager = epochsManager;\\n        _rewardsManager = rewardsManager;\\n        _authorizedAccounts = authorizedAccounts;\\n        _futurepassRegistrar = futurepassRegistrar;\\n\\n        unlockDuration = _unlockDuration;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract implements the interface defined by\\n     * `interfaceId` from ERC165.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(ISyloTicketing).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Set the unlock duration for deposits. Only callable\\n     * by the owner.\\n     * @param _unlockDuration The unlock duration in blocks.\\n     */\\n    function setUnlockDuration(uint256 _unlockDuration) external onlyOwner {\\n        if (_unlockDuration == 0) {\\n            revert UnlockDurationCannotBeZero();\\n        }\\n\\n        unlockDuration = _unlockDuration;\\n        emit UnlockDurationUpdated(_unlockDuration);\\n    }\\n\\n    /**\\n     * @notice Use this function to deposit funds into the\\n     * escrow. This will fail if the deposit is currently being\\n     * unlocked.\\n     * @param amount The amount in SOLO to add to the escrow.\\n     * @param account The address of the account holding the escrow.\\n     */\\n    function depositEscrow(uint256 amount, address account) external {\\n        if (amount == 0) {\\n            revert EscrowAmountCannotBeZero();\\n        }\\n        if (account == address(0)) {\\n            revert AccountCannotBeZeroAddress();\\n        }\\n\\n        Deposit storage deposit = getDeposit(account);\\n        if (deposit.unlockAt != 0) {\\n            revert UnlockingInProcess();\\n        }\\n\\n        deposit.escrow = deposit.escrow + amount;\\n\\n        SafeERC20.safeTransferFrom(_token, msg.sender, address(this), amount);\\n    }\\n\\n    /**\\n     * @notice Use this function to deposit funds into the\\n     * penalty. This will fail if the deposit is currently being\\n     * unlocked.\\n     * @param amount The amount in SOLO to add to the escrow.\\n     * @param account The address of the account holding the penalty.\\n     */\\n    function depositPenalty(uint256 amount, address account) external {\\n        if (amount == 0) {\\n            revert PenaltyAmountCannotBeZero();\\n        }\\n        if (account == address(0)) {\\n            revert AccountCannotBeZeroAddress();\\n        }\\n\\n        Deposit storage deposit = getDeposit(account);\\n        if (deposit.unlockAt != 0) {\\n            revert UnlockingInProcess();\\n        }\\n\\n        deposit.penalty = deposit.penalty + amount;\\n\\n        SafeERC20.safeTransferFrom(_token, msg.sender, address(this), amount);\\n    }\\n\\n    /**\\n     * @notice Call this function to begin unlocking deposits. This function\\n     * will fail if no deposit exists, or if the unlock process has\\n     * already begun.\\n     */\\n    function unlockDeposits() external returns (uint256) {\\n        Deposit storage deposit = getDeposit(msg.sender);\\n\\n        if (deposit.escrow == 0 && deposit.penalty == 0) {\\n            revert NoEsrowAndPenalty();\\n        }\\n        if (deposit.unlockAt != 0) {\\n            revert UnlockingInProcess();\\n        }\\n\\n        deposit.unlockAt = block.number + unlockDuration;\\n\\n        return deposit.unlockAt;\\n    }\\n\\n    /**\\n     * @notice Call this function to cancel any deposit that is in the\\n     * unlocking process.\\n     */\\n    function lockDeposits() external {\\n        Deposit storage deposit = getDeposit(msg.sender);\\n        if (deposit.unlockAt == 0) {\\n            revert UnlockingNotInProcess();\\n        }\\n\\n        delete deposit.unlockAt;\\n    }\\n\\n    /**\\n     * @notice Call this function once the unlock duration has\\n     * elapsed in order to transfer the unlocked tokens to the caller's account.\\n     */\\n    function withdraw() external {\\n        return withdrawTo(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Call this function once the unlock duration has\\n     * elapsed in order to transfer the unlocked tokens to the specified\\n     * account.\\n     * @param account The address of the account the tokens should be\\n     * transferred to.\\n     */\\n    function withdrawTo(address account) public {\\n        Deposit memory deposit = getDeposit(msg.sender);\\n        if (deposit.unlockAt == 0) {\\n            revert UnlockingNotInProcess();\\n        }\\n        if (deposit.unlockAt >= block.number) {\\n            revert UnlockingNotCompleted();\\n        }\\n\\n        uint256 amount = deposit.escrow + deposit.penalty;\\n\\n        // Reset deposit values to 0\\n        delete deposits[msg.sender];\\n\\n        SafeERC20.safeTransfer(_token, account, amount);\\n    }\\n\\n    /**\\n     * @notice Nodes should call this function on completing an event\\n     * delivery. This function will fail if the ticket is invalid or if the\\n     * ticket is not a winner. Clients should calculate if the ticket is a\\n     * winner locally, but can also use the public view functions:\\n     * `requireValidWinningTicket` and `isWinningTicket` to check that a ticket\\n     * is winning.\\n     * @param ticket The ticket issued by the sender.\\n     * @param redeemerRand The redeemer random value, generated by the Node prior\\n     * to performing the event relay.\\n     * @param senderSig The signature of the sender of the ticket.\\n     * @param receiverSig The signature of the redeemer of the ticket.\\n     */\\n    function redeem(\\n        Ticket calldata ticket,\\n        uint256 redeemerRand,\\n        bytes calldata senderSig,\\n        bytes calldata receiverSig\\n    ) external {\\n        EpochsManager.Epoch memory epoch = _epochsManager.getEpoch(ticket.epochId);\\n        if (ticket.generationBlock > block.number) {\\n            revert TicketCannotBeFromFutureBlock();\\n        }\\n\\n        bytes32 ticketHash = requireValidWinningTicket(\\n            ticket,\\n            redeemerRand,\\n            senderSig,\\n            receiverSig\\n        );\\n\\n        usedTickets[ticketHash] = true;\\n\\n        uint256 directoryStake = _directory.getTotalStakeForStakee(\\n            ticket.epochId,\\n            ticket.redeemer\\n        );\\n        if (directoryStake == 0) {\\n            revert RedeemerMustHaveJoinedEpoch(ticket.epochId);\\n        }\\n\\n        _redeem(epoch, ticket);\\n    }\\n\\n    /**\\n     * @notice Nodes should call this function on completing a one-to-many event\\n     * delivery. This function will fail if the ticket is invalid or if the\\n     * ticket is not a winner. Additionally, the specified receiver must have\\n     * a valid futurepass account associated with it. Clients should calculate\\n     * if the ticket is a winner locally, but can also use the public view\\n     * functions:\\n     * `requireValidWinningMultiReceiverTicket` and `isWinningTicket` to check\\n     * that a ticket is winning.\\n     * @param ticket The ticket issued by the sender.\\n     * @param redeemerRand The redeemer random value, generated by the Node prior\\n     * to performing the event relay.\\n     * @param receiver A valid receiver of the the relay.\\n     * @param senderSig The signature of the sender of the ticket.\\n     * @param receiverSig The signature of the redeemer of the ticket.\\n     */\\n    function redeemMultiReceiver(\\n        MultiReceiverTicket calldata ticket,\\n        uint256 redeemerRand,\\n        User calldata receiver,\\n        bytes calldata senderSig,\\n        bytes calldata receiverSig\\n    ) external {\\n        EpochsManager.Epoch memory epoch = _epochsManager.getEpoch(ticket.epochId);\\n        if (ticket.generationBlock > block.number) {\\n            revert TicketCannotBeFromFutureBlock();\\n        }\\n\\n        (, bytes32 ticketReceiverHash) = requireValidWinningMultiReceiverTicket(\\n            ticket,\\n            receiver,\\n            redeemerRand,\\n            senderSig,\\n            receiverSig\\n        );\\n\\n        usedTickets[ticketReceiverHash] = true;\\n\\n        uint256 directoryStake = _directory.getTotalStakeForStakee(\\n            ticket.epochId,\\n            ticket.redeemer\\n        );\\n        if (directoryStake == 0) {\\n            revert RedeemerMustHaveJoinedEpoch(ticket.epochId);\\n        }\\n\\n        _redeemMultiReceiver(epoch, ticket, receiver.main);\\n    }\\n\\n    function _redeem(EpochsManager.Epoch memory epoch, Ticket calldata ticket) internal {\\n        uint256 rewardAmount = rewardRedeemer(epoch, ticket.sender, ticket.redeemer);\\n\\n        emit Redemption(\\n            ticket.epochId,\\n            ticket.redeemer,\\n            ticket.sender.main,\\n            ticket.receiver.main,\\n            ticket.generationBlock,\\n            rewardAmount\\n        );\\n    }\\n\\n    function _redeemMultiReceiver(\\n        EpochsManager.Epoch memory epoch,\\n        MultiReceiverTicket calldata ticket,\\n        address receiver\\n    ) internal {\\n        uint256 rewardAmount = rewardRedeemer(epoch, ticket.sender, ticket.redeemer);\\n\\n        emit MultiReceiverRedemption(\\n            ticket.epochId,\\n            ticket.redeemer,\\n            ticket.sender.main,\\n            receiver,\\n            ticket.generationBlock,\\n            rewardAmount\\n        );\\n    }\\n\\n    function rewardRedeemer(\\n        EpochsManager.Epoch memory epoch,\\n        User calldata sender,\\n        address redeemer\\n    ) internal returns (uint256) {\\n        Deposit storage deposit = getDeposit(sender.main);\\n\\n        uint256 amount;\\n\\n        if (epoch.faceValue > deposit.escrow) {\\n            amount = deposit.escrow;\\n            incrementRewardPool(redeemer, deposit, amount);\\n            SafeERC20.safeTransfer(\\n                _token,\\n                address(0x000000000000000000000000000000000000dEaD),\\n                deposit.penalty\\n            );\\n\\n            delete deposit.penalty;\\n            emit SenderPenaltyBurnt(sender.main);\\n        } else {\\n            amount = epoch.faceValue;\\n            incrementRewardPool(redeemer, deposit, amount);\\n        }\\n\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Call this function to check if a ticket is valid and is\\n     * a winning ticket. It will fail if the ticket is invalid or is not\\n     * a winner. A ticket is invalid if:\\n     *      - The sender or redeemer addresses are null\\n     *      - The ticket has already been redeemed.\\n     *      - The secret random value of the sender does not match the commit\\n     *        in the ticket.\\n     *      - The signatures are invalid.\\n     * @param ticket The ticket issued by the sender.\\n     * @param redeemerRand The redeemer random value, generated by the Node prior\\n     * to performing the event relay.\\n     * @param senderSig The signature of the sender of the ticket.\\n     * @param receiverSig The signature of the redeemer of the ticket.\\n     * @return ticketHash The hash of the ticket. Should match the hash generated\\n     * by `getTicketHash`.\\n     */\\n    function requireValidWinningTicket(\\n        Ticket memory ticket,\\n        uint256 redeemerRand,\\n        bytes calldata senderSig,\\n        bytes calldata receiverSig\\n    ) public view returns (bytes32 ticketHash) {\\n        if (ticket.sender.main == address(0)) {\\n            revert TicketSenderCannotBeZeroAddress();\\n        }\\n        if (ticket.receiver.main == address(0)) {\\n            revert TicketReceiverCannotBeZeroAddress();\\n        }\\n        if (ticket.redeemer == address(0)) {\\n            revert TicketRedeemerCannotBeZeroAddress();\\n        }\\n\\n        ticketHash = getTicketHash(ticket);\\n        if (usedTickets[ticketHash]) {\\n            revert TicketAlreadyRedeemed();\\n        }\\n\\n        // validate the redeemer has knowledge of the redeemer rand\\n        if (createCommit(ticket.generationBlock, redeemerRand) != ticket.redeemerCommit) {\\n            revert RedeemerCommitMismatch();\\n        }\\n\\n        if (!hasSigningPermission(ticket.sender, ticket.generationBlock)) {\\n            revert InvalidSenderSigningPermission();\\n        }\\n        if (!hasSigningPermission(ticket.receiver, ticket.generationBlock)) {\\n            revert InvalidReceiverSigningPermission();\\n        }\\n\\n        if (!isValidTicketSig(ticket.sender, senderSig, ticketHash)) {\\n            revert InvalidSenderSignature();\\n        }\\n        if (!isValidTicketSig(ticket.receiver, receiverSig, ticketHash)) {\\n            revert InvalidReceiverSignature();\\n        }\\n\\n        if (\\n            !isWinningTicket(\\n                senderSig,\\n                receiverSig,\\n                ticket.epochId,\\n                ticket.generationBlock,\\n                redeemerRand\\n            )\\n        ) {\\n            revert TicketNotWinning();\\n        }\\n    }\\n\\n    /**\\n     * @notice Call this function to check if a multi receiver ticket is valid and is\\n     * a winning ticket. It will fail if the ticket is invalid or is not\\n     * a winner. A ticket is invalid if:\\n     *      - The sender, receiver or redeemer addresses are null\\n     *      - The receiver does not have a valid futurepass account\\n     *      - The ticket has already been redeemed.\\n     *      - The secret random value of the redeemer does not match the commit\\n     *        in the ticket.\\n     *      - The signatures are invalid.\\n     * @param ticket The ticket issued by the sender.\\n     * @param receiver The receiver associated with the ticket.\\n     * @param redeemerRand The redeemer random value, generated by the Node prior\\n     * to performing the event relay.\\n     * @param senderSig The signature of the sender of the ticket.\\n     * @param receiverSig The signature of the redeemer of the ticket.\\n     */\\n    function requireValidWinningMultiReceiverTicket(\\n        MultiReceiverTicket memory ticket,\\n        User calldata receiver,\\n        uint256 redeemerRand,\\n        bytes calldata senderSig,\\n        bytes calldata receiverSig\\n    ) public view returns (bytes32 ticketHash, bytes32 ticketReceiverHash) {\\n        if (ticket.sender.main == address(0)) {\\n            revert TicketSenderCannotBeZeroAddress();\\n        }\\n        if (receiver.main == address(0)) {\\n            revert TicketReceiverCannotBeZeroAddress();\\n        }\\n        if (ticket.redeemer == address(0)) {\\n            revert TicketRedeemerCannotBeZeroAddress();\\n        }\\n\\n        address futurepassAccount = _futurepassRegistrar.futurepassOf(receiver.main);\\n        if (futurepassAccount == address(0)) {\\n            revert MissingFuturepassAccount(receiver.main);\\n        }\\n\\n        // There are two hashes create. The first hash is signed by the\\n        // sender and receiver, and is primarily used to validate these actors\\n        // agreed on the contents of the ticket.\\n        // The second hash is to prevent re-use. In a multi-receiver context,\\n        // the same ticket can be re-used amongst many receiver, but should\\n        // only be used ONCE per futurepass account. Thus the second hash\\n        // additionally appends the futurepass address as well.\\n        ticketHash = getMultiReceiverTicketHash(ticket);\\n        ticketReceiverHash = keccak256(abi.encodePacked(ticketHash, futurepassAccount));\\n        if (usedTickets[ticketReceiverHash]) {\\n            revert TicketAlreadyRedeemed();\\n        }\\n\\n        // validate the redeemer has knowledge of the redeemer rand\\n        if (createCommit(ticket.generationBlock, redeemerRand) != ticket.redeemerCommit) {\\n            revert RedeemerCommitMismatch();\\n        }\\n\\n        if (!hasSigningPermission(ticket.sender, ticket.generationBlock)) {\\n            revert InvalidSenderSigningPermission();\\n        }\\n        if (!hasSigningPermission(receiver, ticket.generationBlock)) {\\n            revert InvalidReceiverSigningPermission();\\n        }\\n\\n        if (!isValidTicketSig(ticket.sender, senderSig, ticketHash)) {\\n            revert InvalidSenderSignature();\\n        }\\n        if (!isValidTicketSig(receiver, receiverSig, ticketHash)) {\\n            revert InvalidReceiverSignature();\\n        }\\n\\n        if (\\n            !isWinningTicket(\\n                senderSig,\\n                receiverSig,\\n                ticket.epochId,\\n                ticket.generationBlock,\\n                redeemerRand\\n            )\\n        ) {\\n            revert TicketNotWinning();\\n        }\\n\\n        return (ticketHash, ticketReceiverHash);\\n    }\\n\\n    function hasSigningPermission(\\n        User memory user,\\n        uint256 generationBlock\\n    ) internal view returns (bool) {\\n        if (user.delegated == address(0)) {\\n            return true;\\n        }\\n\\n        IAuthorizedAccounts.Permission permission = IAuthorizedAccounts.Permission.PersonalSign;\\n        return\\n            _authorizedAccounts.validatePermission(\\n                user.main,\\n                user.delegated,\\n                permission,\\n                generationBlock\\n            );\\n    }\\n\\n    function createCommit(uint256 generationBlock, uint256 rand) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(keccak256(abi.encodePacked(generationBlock, rand))));\\n    }\\n\\n    function getDeposit(address account) private view returns (Deposit storage) {\\n        return deposits[account];\\n    }\\n\\n    function isValidTicketSig(\\n        User memory user,\\n        bytes memory sig,\\n        bytes32 ticketHash\\n    ) internal pure returns (bool) {\\n        address signer = address(0);\\n        if (user.delegated != address(0)) {\\n            signer = user.delegated;\\n        } else {\\n            signer = user.main;\\n        }\\n        bytes32 ethHash = ECDSA.toEthSignedMessageHash(ticketHash);\\n        return ECDSA.recover(ethHash, sig) == signer;\\n    }\\n\\n    /**\\n     * @notice Use this function to check if a ticket is winning.\\n     * @param senderSig The signature of the sender of the ticket.\\n     * @param receiverSig The signature of the receiver of the ticket.\\n     * @param epochId The epochId of the ticket.\\n     * @param generationBlock The generationBlock of the ticket.\\n     * @param redeemerRand The redeemer random value, generated by the Node prior\\n     * to performing the event relay.\\n     * @return True if a ticket is a winner.\\n     */\\n    function isWinningTicket(\\n        bytes memory senderSig,\\n        bytes memory receiverSig,\\n        uint256 epochId,\\n        uint256 generationBlock,\\n        uint256 redeemerRand\\n    ) public view returns (bool) {\\n        uint256 winProb = calculateWinningProbability(epochId, generationBlock);\\n        // bitshift the winProb to a 256 bit value to allow comparison to a 32 byte hash\\n        uint256 prob = (uint256(winProb) << 128) | uint256(winProb);\\n        return uint256(keccak256(abi.encodePacked(senderSig, receiverSig, redeemerRand))) < prob;\\n    }\\n\\n    /**\\n     * @notice This function calculates the probability of a ticket winning at\\n     * the block that this function was called. A ticket's winning probability\\n     * will decay every block since its issuance. The amount of decay will depend\\n     * on the decay rate parameter of the epoch the ticket was generated in.\\n     * @param epochId The epochId of the ticket.\\n     * @param generationBlock The generationBlock of the ticket.\\n     */\\n    function calculateWinningProbability(\\n        uint256 epochId,\\n        uint256 generationBlock\\n    ) public view returns (uint128) {\\n        EpochsManager.Epoch memory epoch = _epochsManager.getEpoch(epochId);\\n        if (epoch.startBlock == 0) {\\n            revert TicketEpochNotFound();\\n        }\\n\\n        if (\\n            generationBlock < epoch.startBlock ||\\n            (epoch.endBlock > 0 && generationBlock >= epoch.endBlock)\\n        ) {\\n            revert TicketNotCreatedInTheEpoch();\\n        }\\n\\n        uint256 elapsedDuration = block.number - generationBlock;\\n\\n        // Ticket has completely expired\\n        if (elapsedDuration >= epoch.ticketDuration) {\\n            return 0;\\n        }\\n\\n        uint256 maxDecayValue = SyloUtils.percOf(epoch.baseLiveWinProb, epoch.decayRate);\\n\\n        // determine the amount of probability that has actually decayed\\n        // by multiplying the maximum decay value against ratio of the tickets elapsed duration\\n        // vs the actual ticket duration. The max decay value is calculated from a fraction of a\\n        // uint128 value so we cannot phantom overflow here\\n        uint256 decayedProbability = (maxDecayValue * elapsedDuration) / epoch.ticketDuration;\\n\\n        // calculate the remaining probability by subtracting the decayed probability\\n        // from the base\\n        return epoch.baseLiveWinProb - SafeCast.toUint128(decayedProbability);\\n    }\\n\\n    /**\\n     * @notice Returns the hash of the ticket. Takes all fields in a ticket\\n     * as inputs to the hash.\\n     * @return A byte-array representing the hash.\\n     */\\n    function getTicketHash(Ticket memory ticket) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    ticket.epochId,\\n                    ticket.sender.main,\\n                    ticket.receiver.main,\\n                    ticket.redeemer,\\n                    ticket.generationBlock,\\n                    ticket.redeemerCommit\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Returns the hash of a multi receiver ticket. Takes all fields in\\n     * a ticket as inputs to the hash, as well as a specific receiver.\\n     * @return A byte-array representing the hash.\\n     */\\n    function getMultiReceiverTicketHash(\\n        MultiReceiverTicket memory ticket\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    ticket.epochId,\\n                    ticket.sender.main,\\n                    ticket.redeemer,\\n                    ticket.generationBlock,\\n                    ticket.redeemerCommit\\n                )\\n            );\\n    }\\n\\n    function incrementRewardPool(\\n        address stakee,\\n        Deposit storage deposit,\\n        uint256 amount\\n    ) internal {\\n        deposit.escrow = deposit.escrow - amount;\\n\\n        SafeERC20.safeTransfer(_token, address(_rewardsManager), amount);\\n        _rewardsManager.incrementRewardPool(stakee, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xd00ea66ee67159b1007b95285b5fb2904ccea3a90afb2650ce08fb626b10256f\",\"license\":\"Apache-2.0\"},\"contracts/payments/ticketing/RewardsManager.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"../../libraries/SyloUtils.sol\\\";\\nimport \\\"../../libraries/Manageable.sol\\\";\\nimport \\\"../../epochs/EpochsManager.sol\\\";\\nimport \\\"../../staking/StakingManager.sol\\\";\\nimport \\\"../../interfaces/epochs/IEpochsManager.sol\\\";\\nimport \\\"../../interfaces/staking/IStakingManager.sol\\\";\\nimport \\\"../../interfaces/payments/ticketing/IRewardsManager.sol\\\";\\n\\n/**\\n * @notice Handles epoch based reward pools that are incremented from redeeming tickets.\\n * Nodes use this contract to set up their reward pool for the next epoch,\\n * and stakers use this contract to track and claim staking rewards.\\n * @dev After deployment, the SyloTicketing contract should be\\n * set up as a manager to be able to call certain restricted functions.\\n */\\ncontract RewardsManager is IRewardsManager, Initializable, Manageable, ERC165 {\\n    uint256 internal constant ONE_SYLO = 1 ether;\\n\\n    // 64x64 Fixed point representation of 1 SYLO (10**18 >> 64)\\n    int128 internal constant ONE_SYLO_FIXED = 18446744073709551616000000000000000000;\\n\\n    uint256 internal constant MAX_INT64 = 9223372036854775807;\\n\\n    /** ERC20 Sylo token contract. */\\n    IERC20 public _token;\\n\\n    /** Sylo Staking Manager contract. */\\n    StakingManager public _stakingManager;\\n\\n    /** Sylo Epochs Manager. */\\n    EpochsManager public _epochsManager;\\n\\n    /**\\n     * @dev Each node will manage a cumulative reward factor (CRF) that is incremented\\n     * whenever a ticket is redeemed. This factor acts as a single value\\n     * that can be used to calculate any particular staker's reward share. This\\n     * prevents the need to individually track each staker's proportion, and also allows\\n     * a claim calculation to be performed without iterating through every epoch.\\n     *\\n     * The CRF is calculated as CRF = CRF + Reward / TotalStake.\\n     */\\n    mapping(address => int128) private cumulativeRewardFactors;\\n\\n    /**\\n     * @notice Tracks the last epoch a delegated staker made a reward claim in.\\n     * The key to this mapping is a hash of the Node's address and the delegated\\n     * stakers address.\\n     */\\n    mapping(bytes32 => LastClaim) public lastClaims;\\n\\n    /**\\n     * @notice Tracks each Nodes total pending rewards in SOLOs. This\\n     * value is accumulated as Node's redeem tickets. Rewards are pending if the\\n     * distribution amongst the stakers has not been accounted for yet. Pending rewards\\n     * are transferred to unclaimed rewards once the the staker's share has been\\n     * calculated.\\n     */\\n    mapping(address => uint256) public pendingRewards;\\n\\n    /**\\n     * @notice Tracks rewards for stakers after the stakers share has been calculated,\\n     * but has not actually been claimed by the staker.\\n     * The node fee reward is also added to the node's unclaimedStakingRewards.\\n     */\\n    mapping(bytes32 => uint256) public unclaimedStakingRewards;\\n\\n    /**\\n     * @notice Tracks each Node's most recently active reward pool\\n     */\\n    mapping(address => uint256) public latestActiveRewardPools;\\n\\n    /**\\n     * @notice Tracks total accumulated rewards in each epoch\\n     */\\n    mapping(uint256 => uint256) public totalEpochRewards;\\n\\n    /**\\n     * @notice Tracks total accumulated staking rewards in each epoch\\n     */\\n    mapping(uint256 => uint256) public totalEpochStakingRewards;\\n\\n    /**\\n     * @notice Tracks each reward pool initialized by a Node. The key to this map\\n     * is derived from the epochId and the Node's address.\\n     */\\n    mapping(bytes32 => RewardPool) public rewardPools;\\n\\n    error NoRewardToClaim();\\n    error AmountCannotBeZero();\\n    error RewardPoolNotExist();\\n    error RewardPoolAlreadyExist();\\n    error DoNotAllowZeroAddress();\\n    error TokenCannotBeZeroAddress();\\n    error NoStakeToCreateRewardPool();\\n    error StakeeCannotBeZeroAddress();\\n    error StakerCannotBeZeroAddress();\\n    error StakerKeyCannotBeZeroBytes();\\n    error InvalidFixedPointResult();\\n\\n    function initialize(\\n        IERC20 token,\\n        StakingManager stakingManager,\\n        EpochsManager epochsManager\\n    ) external initializer {\\n        if (address(token) == address(0)) {\\n            revert TokenCannotBeZeroAddress();\\n        }\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"StakingManager\\\",\\n            address(stakingManager),\\n            type(IStakingManager).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"EpochsManager\\\",\\n            address(epochsManager),\\n            type(IEpochsManager).interfaceId\\n        );\\n\\n        Ownable2StepUpgradeable.__Ownable2Step_init();\\n\\n        _token = token;\\n        _epochsManager = epochsManager;\\n        _stakingManager = stakingManager;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract implements the interface defined by\\n     * `interfaceId` from ERC165.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IRewardsManager).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Returns the key used to index a reward pool. The key is a hash of\\n     * the epochId and Node's address.\\n     * @param epochId The epoch ID the reward pool was created in.\\n     * @param stakee The address of the Node.\\n     * @return A byte-array representing the reward pool key.\\n     */\\n    function getRewardPoolKey(uint256 epochId, address stakee) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(epochId, stakee));\\n    }\\n\\n    /**\\n     * @notice Returns the key used to index staking claims. The key is a hash of\\n     * the Node's address and the staker's address.\\n     * @param stakee The address of the Node.\\n     * @param staker The address of the stake.\\n     * @return A byte-array representing the key.\\n     */\\n    function getStakerKey(address stakee, address staker) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(stakee, staker));\\n    }\\n\\n    /**\\n     * @notice Retrieve the reward pool initialized by the given node, at the specified\\n     * epoch.\\n     * @param epochId The ID of the epoch the reward pool was initialized in.\\n     * @param stakee The address of the Node.\\n     * @return The reward pool.\\n     */\\n    function getRewardPool(\\n        uint256 epochId,\\n        address stakee\\n    ) external view returns (RewardPool memory) {\\n        return rewardPools[getRewardPoolKey(epochId, stakee)];\\n    }\\n\\n    /**\\n     * @notice Retrieve the total accumulated reward that will be distributed to a Node's\\n     * delegated stakers for a given epoch.\\n     * @param epochId The ID of the epoch the reward pool was initialized in.\\n     * @param stakee The address of the Node.\\n     * @return The total accumulated staker reward in SOLO.\\n     */\\n    function getRewardPoolStakersTotal(\\n        uint256 epochId,\\n        address stakee\\n    ) external view returns (uint256) {\\n        return rewardPools[getRewardPoolKey(epochId, stakee)].stakersRewardTotal;\\n    }\\n\\n    /**\\n     * @notice Retrieve the total active stake that will be used for a Node's reward\\n     * pool in a given epoch.\\n     * @param epochId The ID of the epoch the reward pool was initialized in.\\n     * @param stakee The address of the Node.\\n     * @return The total active stake for that reward pool in SOLO.\\n     */\\n    function getRewardPoolActiveStake(\\n        uint256 epochId,\\n        address stakee\\n    ) external view returns (uint256) {\\n        return rewardPools[getRewardPoolKey(epochId, stakee)].totalActiveStake;\\n    }\\n\\n    /**\\n     * @notice Retrieve the total pending staking reward allocated to a Node's\\n     * stakers.\\n     * @param stakee The address of the Node.\\n     * @return The total pending staking reward in SOLO.\\n     */\\n    function getPendingRewards(address stakee) external view returns (uint256) {\\n        return pendingRewards[stakee];\\n    }\\n\\n    /**\\n     * @notice Retrieves the ID of the epoch in which a staker last made their\\n     * staking claim.\\n     * @param stakee The address of the Node.\\n     * @param staker The address of the staker.\\n     * @return The ID of the epoch.\\n     */\\n    function getLastClaim(\\n        address stakee,\\n        address staker\\n    ) external view returns (LastClaim memory) {\\n        return lastClaims[getStakerKey(stakee, staker)];\\n    }\\n\\n    /**\\n     * @notice Retrieves the total accumulated rewards for a specific epoch.\\n     * @param epochId The epoch id.\\n     * @return The total reward in that epoch, including staking rewards and fee\\n     * reward.\\n     */\\n    function getTotalEpochRewards(uint256 epochId) external view returns (uint256) {\\n        return totalEpochRewards[epochId];\\n    }\\n\\n    /**\\n     * @notice Retrieves the total accumulated rewards for stakers in a specific epoch.\\n     * @param epochId The epoch id.\\n     * @return The total staking reward in that epoch.\\n     */\\n    function getTotalEpochStakingRewards(uint256 epochId) external view returns (uint256) {\\n        return totalEpochStakingRewards[epochId];\\n    }\\n\\n    /**\\n     * @notice This is used by Nodes to initialize their reward pool for\\n     * the next epoch. This function will revert if the caller has no stake, or\\n     * if the reward pool has already been initialized. The total active stake\\n     * for the next reward pool is calculated by summing up the total managed\\n     * stake held by the RewardsManager contract.\\n     */\\n    function initializeNextRewardPool(address stakee) external onlyManager {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n\\n        uint256 nextEpochId = _epochsManager.getNextEpochId();\\n\\n        RewardPool storage nextRewardPool = rewardPools[getRewardPoolKey(nextEpochId, stakee)];\\n        if (nextRewardPool.initializedAt != 0) {\\n            revert RewardPoolAlreadyExist();\\n        }\\n\\n        uint256 totalStake = _stakingManager.getStakeeTotalManagedStake(stakee);\\n        if (totalStake == 0) {\\n            revert NoStakeToCreateRewardPool();\\n        }\\n\\n        nextRewardPool.totalActiveStake = totalStake;\\n\\n        nextRewardPool.initializedAt = block.number;\\n    }\\n\\n    /**\\n     * @dev This function should be called by the Ticketing contract when a\\n     * ticket is successfully redeemed. The face value of the ticket\\n     * should be split between incrementing the node's reward balance,\\n     * and the reward balance for the node's delegated stakers. The face value\\n     * will be added to the current reward pool's balance. This function will\\n     * fail if the Ticketing contract has not been set as a manager.\\n     * @param stakee The address of the Node.\\n     * @param amount The face value of the ticket in SOLO.\\n     */\\n    function incrementRewardPool(address stakee, uint256 amount) external onlyManager {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n        if (amount == 0) {\\n            revert AmountCannotBeZero();\\n        }\\n\\n        (uint256 epochId, IEpochsManager.Epoch memory currentEpoch) = _epochsManager\\n            .getCurrentActiveEpoch();\\n\\n        RewardPool storage rewardPool = rewardPools[getRewardPoolKey(epochId, stakee)];\\n        if (rewardPool.initializedAt == 0) {\\n            revert RewardPoolNotExist();\\n        }\\n\\n        // Update the latest active reward pool for the node to be this pool\\n        if (latestActiveRewardPools[stakee] < epochId) {\\n            latestActiveRewardPools[stakee] = epochId;\\n        }\\n\\n        uint256 stakersReward = SyloUtils.percOf(\\n            SafeCast.toUint128(amount),\\n            currentEpoch.defaultPayoutPercentage\\n        );\\n\\n        // transfer the node's fee reward to it's unclaimed reward value\\n        unclaimedStakingRewards[getStakerKey(stakee, stakee)] =\\n            unclaimedStakingRewards[getStakerKey(stakee, stakee)] +\\n            (amount - stakersReward);\\n\\n        // update the value of the reward owed to the stakers\\n        pendingRewards[stakee] = pendingRewards[stakee] + stakersReward;\\n\\n        // if this is the first ticket redeemed for this reward, set the initial\\n        // CRF value for this pool\\n        if (rewardPool.stakersRewardTotal == 0) {\\n            rewardPool.initialCumulativeRewardFactor = cumulativeRewardFactors[stakee];\\n        }\\n\\n        rewardPool.stakersRewardTotal = rewardPool.stakersRewardTotal + stakersReward;\\n\\n        // We preemptively prevent an overflow revert with the abdk library.\\n        // Dividing the stakers reward with the pool's total active\\n        // stake may produce a value that is greater than the maximum possible\\n        // 64.64 fixed point value.\\n        // This error is incredibly niche and unlikely to happen, so we just\\n        // revert here as well (with a named error) and remediation involves\\n        // just increasing the amount of stake a node has.\\n        if (rewardPool.totalActiveStake * MAX_INT64 < stakersReward) {\\n            revert InvalidFixedPointResult();\\n        }\\n\\n        cumulativeRewardFactors[stakee] = ABDKMath64x64.add(\\n            cumulativeRewardFactors[stakee],\\n            ABDKMath64x64.div(\\n                toFixedPointSYLO(stakersReward),\\n                toFixedPointSYLO(rewardPool.totalActiveStake)\\n            )\\n        );\\n\\n        totalEpochRewards[epochId] = totalEpochRewards[epochId] + amount;\\n        totalEpochStakingRewards[epochId] = totalEpochStakingRewards[epochId] + stakersReward;\\n    }\\n\\n    /**\\n     * @dev This function utilizes the cumulative reward factors, and the staker's\\n     * value in stake to calculate the staker's share of the pending reward.\\n     */\\n    function calculatePendingClaim(\\n        bytes32 stakerKey,\\n        address stakee,\\n        address staker\\n    ) internal view returns (uint256) {\\n        uint256 claim = calculateInitialClaim(stakerKey, stakee);\\n\\n        // find the first reward pool where their stake was active and had\\n        // generated rewards\\n        uint256 activeAt;\\n        RewardPool memory initialActivePool;\\n\\n        uint256 currentEpochId = _epochsManager.currentIteration();\\n\\n        for (uint256 i = lastClaims[stakerKey].claimedAt + 1; i < currentEpochId; ++i) {\\n            initialActivePool = rewardPools[getRewardPoolKey(i, stakee)];\\n            // check if node initialized a reward pool for this epoch and\\n            // gained rewards\\n            if (initialActivePool.initializedAt > 0 && initialActivePool.stakersRewardTotal > 0) {\\n                activeAt = i;\\n                break;\\n            }\\n        }\\n\\n        if (activeAt == 0) {\\n            return claim;\\n        }\\n\\n        IStakingManager.StakeEntry memory stakeEntry = _stakingManager.getStakeEntry(\\n            stakee,\\n            staker\\n        );\\n\\n        // We convert the staker amount to SYLO as the maximum uint256 value that\\n        // can be used for the fixed point representation is 2^64-1.\\n        int128 initialStake = toFixedPointSYLO(stakeEntry.amount);\\n\\n        int128 initialCumulativeRewardFactor = initialActivePool.initialCumulativeRewardFactor;\\n\\n        int128 finalCumulativeRewardFactor = getFinalCumulativeRewardFactor(\\n            stakee,\\n            currentEpochId\\n        );\\n\\n        return\\n            claim +\\n            fromFixedPointSYLO(\\n                ABDKMath64x64.mul(\\n                    initialStake,\\n                    ABDKMath64x64.sub(finalCumulativeRewardFactor, initialCumulativeRewardFactor)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * Manually calculates the reward claim for the first epoch the claim is being\\n     * made for. This manual calculation is necessary as claims are only made up\\n     * to the previous epoch.\\n     */\\n    function calculateInitialClaim(\\n        bytes32 stakerKey,\\n        address stakee\\n    ) internal view returns (uint256) {\\n        LastClaim memory lastClaim = lastClaims[stakerKey];\\n\\n        // if we have already made a claim up to the previous epoch, then\\n        // there is no need to calculate the initial claim\\n        if (_epochsManager.currentIteration() == lastClaim.claimedAt) {\\n            return 0;\\n        }\\n\\n        RewardPool memory firstRewardPool = rewardPools[\\n            getRewardPoolKey(lastClaim.claimedAt, stakee)\\n        ];\\n\\n        // if there was no reward pool initialized for the first epoch,\\n        // then there is no need to calculate the initial claim\\n        if (firstRewardPool.totalActiveStake == 0) {\\n            return 0;\\n        }\\n\\n        return\\n            (firstRewardPool.stakersRewardTotal * lastClaim.stake) /\\n            firstRewardPool.totalActiveStake;\\n    }\\n\\n    /**\\n     * Determines the cumulative reward factor to use for claim calculations. The\\n     * CRF will depend on when the Node last initialized a reward pool, and also when\\n     * the staker last made their claim.\\n     */\\n    function getFinalCumulativeRewardFactor(\\n        address stakee,\\n        uint256 currentEpochId\\n    ) internal view returns (int128) {\\n        int128 finalCumulativeRewardFactor;\\n\\n        // Get the cumulative reward factor for the Node\\n        // for the start of this epoch, since we only perform\\n        // calculations up to the end of the previous epoch.\\n        if (latestActiveRewardPools[stakee] < currentEpochId) {\\n            // If the Node has not been active, then the final\\n            // cumulative reward factor will just be the current one.\\n            finalCumulativeRewardFactor = cumulativeRewardFactors[stakee];\\n        } else {\\n            // We are calculating the claim for an active epoch, the\\n            // final cumulative reward factor will be taken from the start of this\\n            // epoch (end of previous epoch).\\n            RewardPool storage latestRewardPool = rewardPools[\\n                getRewardPoolKey(latestActiveRewardPools[stakee], stakee)\\n            ];\\n            finalCumulativeRewardFactor = latestRewardPool.initialCumulativeRewardFactor;\\n        }\\n\\n        return finalCumulativeRewardFactor;\\n    }\\n\\n    /**\\n     * @notice Call this function to calculate the total reward owed to a staker.\\n     * This value will include all epochs since the last claim was made up to\\n     * the previous epoch. This will also add any pending rewards to the\\n     * final value as well.\\n     * @dev This function will utilize the cumulative reward factor to perform the\\n     * calculation, keeping the gas cost scaling of this function to a constant value.\\n     * @param stakee The address of the Node.\\n     * @param staker The address of the staker.\\n     * @return The value of the reward owed to the staker in SOLO.\\n     */\\n    function calculateStakerClaim(address stakee, address staker) public view returns (uint256) {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n        if (staker == address(0)) {\\n            revert StakerCannotBeZeroAddress();\\n        }\\n\\n        bytes32 stakerKey = getStakerKey(stakee, staker);\\n        uint256 pendingClaim = calculatePendingClaim(stakerKey, stakee, staker);\\n\\n        return pendingClaim + unclaimedStakingRewards[stakerKey];\\n    }\\n\\n    /**\\n     * Helper function to convert a uint256 value in SOLOs to a 64.64 fixed point\\n     * representation in SYLOs while avoiding any possibility of overflow.\\n     * Any remainders from converting SOLO to SYLO is explicitly handled to mitigate\\n     * precision loss. The error when using this function is [-1/2^64, 0].\\n     */\\n    function toFixedPointSYLO(uint256 amount) internal pure returns (int128) {\\n        int128 fullSylos = ABDKMath64x64.fromUInt(amount / ONE_SYLO);\\n        int128 fracSylos = ABDKMath64x64.fromUInt(amount % ONE_SYLO); // remainder\\n\\n        return ABDKMath64x64.add(fullSylos, ABDKMath64x64.div(fracSylos, ONE_SYLO_FIXED));\\n    }\\n\\n    /**\\n     * Helper function to convert a 64.64 fixed point value in SYLOs to a uint256\\n     * representation in SOLOs while avoiding any possibility of overflow.\\n     */\\n    function fromFixedPointSYLO(int128 amount) internal pure returns (uint256) {\\n        uint256 fullSylos = ABDKMath64x64.toUInt(amount);\\n        uint256 fullSolos = fullSylos * ONE_SYLO;\\n\\n        // calculate the value lost when converting the fixed point amount to a uint\\n        int128 fracSylos = ABDKMath64x64.sub(amount, ABDKMath64x64.fromUInt(fullSylos));\\n        uint256 fracSolos = ABDKMath64x64.toUInt(ABDKMath64x64.mul(fracSylos, ONE_SYLO_FIXED));\\n\\n        return fullSolos + fracSolos;\\n    }\\n\\n    /**\\n     * @notice Call this function to claim rewards as a staker. The\\n     * SYLO tokens will be transferred to the caller's account. This function will\\n     * fail if there exists no reward to claim. Note: Calling this will remove\\n     * the current unclaimed reward from being used as stake in the next round.\\n     * @param stakee The address of the Node to claim against.\\n     */\\n    function claimStakingRewards(address stakee) external returns (uint256) {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n\\n        bytes32 stakerKey = getStakerKey(stakee, msg.sender);\\n        uint256 pendingReward = calculatePendingClaim(stakerKey, stakee, msg.sender);\\n\\n        uint256 totalClaim = pendingReward + unclaimedStakingRewards[stakerKey];\\n        if (totalClaim == 0) {\\n            revert NoRewardToClaim();\\n        }\\n\\n        delete unclaimedStakingRewards[stakerKey];\\n        pendingRewards[stakee] = pendingRewards[stakee] - pendingReward;\\n\\n        updateLastClaim(stakee, msg.sender);\\n\\n        SafeERC20.safeTransfer(_token, msg.sender, totalClaim);\\n\\n        return totalClaim;\\n    }\\n\\n    /**\\n     * @notice This is called by the staking manager to transfer pending rewards\\n     * to unclaimed rewards for a staker. This is required as the last used CRF\\n     * needs to be updated whenever stake changes.\\n     */\\n    function updatePendingRewards(address stakee, address staker) external onlyManager {\\n        bytes32 stakerKey = getStakerKey(stakee, staker);\\n        uint256 pendingReward = calculatePendingClaim(stakerKey, stakee, staker);\\n\\n        pendingRewards[stakee] = pendingRewards[stakee] - pendingReward;\\n\\n        unclaimedStakingRewards[stakerKey] = unclaimedStakingRewards[stakerKey] + pendingReward;\\n\\n        updateLastClaim(stakee, staker);\\n    }\\n\\n    function updateLastClaim(address stakee, address staker) internal {\\n        IStakingManager.StakeEntry memory stakeEntry = _stakingManager.getStakeEntry(\\n            stakee,\\n            staker\\n        );\\n        lastClaims[getStakerKey(stakee, staker)] = LastClaim(\\n            _epochsManager.currentIteration(),\\n            stakeEntry.amount\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x906af015c975637b6a99d70795b0652f6e28aaa66e5c64a4bae34bff14c99551\",\"license\":\"Apache-2.0\"},\"contracts/payments/ticketing/TicketingParameters.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"../../libraries/SyloUtils.sol\\\";\\nimport \\\"../../interfaces/payments/ticketing/ITicketingParameters.sol\\\";\\n\\n/**\\n * @dev Persists the parameters for the ticketing mechanism. This contract is\\n * read by the EpochManager. Extracting the parameters into another\\n * contract is necessary to avoid a cyclic dependency between the ticketing\\n * and epoch contracts.\\n */\\ncontract TicketingParameters is\\n    ITicketingParameters,\\n    Initializable,\\n    Ownable2StepUpgradeable,\\n    ERC165\\n{\\n    /** @notice The value of a winning ticket in SOLO. */\\n    uint256 public faceValue;\\n\\n    /**\\n     * @notice The probability of a ticket winning during the start of its lifetime.\\n     * This is a uint128 value representing the numerator in the probability\\n     * ratio where 2^128 - 1 is the denominator.\\n     */\\n    uint128 public baseLiveWinProb;\\n\\n    /**\\n     * @notice The probability of a ticket winning after it has expired.\\n     * This is a uint128 value representing the numerator in the probability\\n     * ratio where 2^128 - 1 is the denominator. Note: Redeeming expired\\n     * tickets is currently not supported.\\n     */\\n    uint128 public expiredWinProb;\\n\\n    /**\\n     * @notice The length in blocks before a ticket is considered expired.\\n     * The default initialization value is 80,000. This equates\\n     * to roughly two weeks (15s per block).\\n     */\\n    uint256 public ticketDuration;\\n\\n    /**\\n     * @notice A percentage value representing the proportion of the base win\\n     * probability that will be decayed once a ticket has expired.\\n     * Example: 80% decayRate indicates that a ticket will decay down to 20% of its\\n     * base win probability upon reaching the block before its expiry.\\n     * The value is expressed as a fraction of 100000.\\n     */\\n    uint32 public decayRate;\\n\\n    event FaceValueUpdated(uint256 faceValue);\\n    event BaseLiveWinProbUpdated(uint128 baseLiveWinprob);\\n    event ExpiredWinProbUpdated(uint128 expiredWinProb);\\n    event TicketDurationUpdated(uint256 ticketDuration);\\n    event DecayRateUpdated(uint32 decayRate);\\n\\n    error FaceValueCannotBeZero();\\n    error TicketDurationCannotBeZero();\\n\\n    function initialize(\\n        uint256 _faceValue,\\n        uint128 _baseLiveWinProb,\\n        uint128 _expiredWinProb,\\n        uint32 _decayRate,\\n        uint256 _ticketDuration\\n    ) external initializer {\\n        if (_faceValue == 0) {\\n            revert FaceValueCannotBeZero();\\n        }\\n        if (_ticketDuration == 0) {\\n            revert TicketDurationCannotBeZero();\\n        }\\n\\n        Ownable2StepUpgradeable.__Ownable2Step_init();\\n\\n        faceValue = _faceValue;\\n        baseLiveWinProb = _baseLiveWinProb;\\n        expiredWinProb = _expiredWinProb;\\n        decayRate = _decayRate;\\n        ticketDuration = _ticketDuration;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract implements the interface defined by\\n     * `interfaceId` from ERC165.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(ITicketingParameters).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Set the face value for tickets in SOLO. Only callable by\\n     * the contract owner.\\n     * @param _faceValue The face value to set in SOLO.\\n     */\\n    function setFaceValue(uint256 _faceValue) external onlyOwner {\\n        if (_faceValue == 0) {\\n            revert FaceValueCannotBeZero();\\n        }\\n\\n        faceValue = _faceValue;\\n        emit FaceValueUpdated(_faceValue);\\n    }\\n\\n    /**\\n     * @notice Set the base live win probability of a ticket. Only callable by\\n     * the contract owner.\\n     * @param _baseLiveWinProb The probability represented as a value\\n     * between 0 to 2**128 - 1.\\n     */\\n    function setBaseLiveWinProb(uint128 _baseLiveWinProb) external onlyOwner {\\n        baseLiveWinProb = _baseLiveWinProb;\\n        emit BaseLiveWinProbUpdated(_baseLiveWinProb);\\n    }\\n\\n    /**\\n     * @notice Set the expired win probability of a ticket. Only callable by\\n     * the contract owner.\\n     * @param _expiredWinProb The probability represented as a value\\n     * between 0 to 2**128 - 1.\\n     */\\n    function setExpiredWinProb(uint128 _expiredWinProb) external onlyOwner {\\n        expiredWinProb = _expiredWinProb;\\n        emit ExpiredWinProbUpdated(_expiredWinProb);\\n    }\\n\\n    /**\\n     * @notice Set the decay rate of a ticket. Only callable by the\\n     * the contract owner.\\n     * @param _decayRate The decay rate as a percentage, where the\\n     * denominator is 10000.\\n     */\\n    function setDecayRate(uint32 _decayRate) external onlyOwner {\\n        decayRate = _decayRate;\\n        emit DecayRateUpdated(_decayRate);\\n    }\\n\\n    /**\\n     * @notice Set the ticket duration of a ticket. Only callable by the\\n     * contract owner.\\n     * @param _ticketDuration The duration of a ticket in number of blocks.\\n     */\\n    function setTicketDuration(uint256 _ticketDuration) external onlyOwner {\\n        if (_ticketDuration == 0) {\\n            revert TicketDurationCannotBeZero();\\n        }\\n\\n        ticketDuration = _ticketDuration;\\n        emit TicketDurationUpdated(_ticketDuration);\\n    }\\n\\n    /**\\n     * @notice Retrieve the current ticketing parameters.\\n     * @return faceValue The face value of a ticket in SOLO.\\n     * @return baseLiveWinProb The base live win probability of a ticket.\\n     * @return expiredWinProb The expired win probability of a ticket.\\n     * @return ticketDuration The duration of a ticket in number of blocks.\\n     * @return decayRate The decay rate of a ticket.\\n     */\\n    function getTicketingParameters()\\n        external\\n        view\\n        returns (uint256, uint128, uint128, uint256, uint32)\\n    {\\n        return (faceValue, baseLiveWinProb, expiredWinProb, ticketDuration, decayRate);\\n    }\\n}\\n\",\"keccak256\":\"0x44b4c2eb70c0583f888ff8fca7ad21b084b6c58a453b7dd914275ccabed98ec0\",\"license\":\"Apache-2.0\"},\"contracts/staking/Directory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"./StakingManager.sol\\\";\\nimport \\\"../libraries/SyloUtils.sol\\\";\\nimport \\\"../libraries/Manageable.sol\\\";\\nimport \\\"../interfaces/staking/IDirectory.sol\\\";\\nimport \\\"../payments/ticketing/RewardsManager.sol\\\";\\n\\n/**\\n * @notice The Directory contract constructs and manages a structure holding the current stakes,\\n * which is queried against using the scan function. The scan function allows submitting\\n * random points which will return a staked node's address in proportion to the stake it has.\\n */\\ncontract Directory is IDirectory, Initializable, Manageable, IERC165 {\\n    /** Sylo Staking Manager contract */\\n    StakingManager public _stakingManager;\\n\\n    /** Sylo Rewards Manager contract */\\n    RewardsManager public _rewardsManager;\\n\\n    /**\\n     * @notice The epoch ID of the current directory.\\n     */\\n    uint256 public currentDirectory;\\n\\n    /**\\n     * @notice Tracks every directory, which will be indexed by an epoch ID\\n     */\\n    mapping(uint256 => EpochDirectory) public directories;\\n\\n    event CurrentDirectoryUpdated(uint256 indexed currentDirectory);\\n\\n    error NoStakeToJoinEpoch();\\n    error StakeeAlreadyJoinedEpoch();\\n    error StakeeCannotBeZeroAddress();\\n    error NoJoiningStakeToJoinEpoch();\\n\\n    function initialize(\\n        StakingManager stakingManager,\\n        RewardsManager rewardsManager\\n    ) external initializer {\\n        SyloUtils.validateContractInterface(\\n            \\\"StakingManager\\\",\\n            address(stakingManager),\\n            type(IStakingManager).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"RewardsManager\\\",\\n            address(rewardsManager),\\n            type(IRewardsManager).interfaceId\\n        );\\n\\n        Ownable2StepUpgradeable.__Ownable2Step_init();\\n\\n        _stakingManager = stakingManager;\\n        _rewardsManager = rewardsManager;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract implements the interface defined by\\n     * `interfaceId` from ERC165.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IDirectory).interfaceId;\\n    }\\n\\n    /**\\n     * @notice This function should be called when a new epoch is initialized.\\n     * This will set the current directory to the specified epoch. This is only\\n     * callable by the owner of this contract, which should be the EpochsManager\\n     * contract.\\n     * @dev After deployment, the EpochsManager should immediately be set as\\n     * the owner.\\n     * @param epochId The ID of the specified epoch.\\n     */\\n    function setCurrentDirectory(uint256 epochId) external onlyManager {\\n        currentDirectory = epochId;\\n        emit CurrentDirectoryUpdated(epochId);\\n    }\\n\\n    /**\\n     * @notice This function is called by the epochs manager as a prerequisite to when the node joins the next epoch.\\n     * @param stakee The address of the node.\\n     * @param seekerId The seekerId of the Seeker that the node is\\n     * registered with when joining the epoch. It is used to determine the nodes\\n     * staking capacity based on its seeker power.\\n     *\\n     * @dev This will construct the directory as nodes join. The directory is constructed\\n     * by creating a boundary value which is a sum of the current directory's total stake, and\\n     * the current stakee's total stake, and pushing the new boundary into the entries array.\\n     * The previous boundary and the current boundary essentially create a range, where if a\\n     * random point were to fall within that range, it would belong to the respective stakee.\\n     * The boundary value grows in size as each stakee joins, thus the directory array\\n     * always remains sorted. This allows us to perform a binary search on the directory.\\n     *\\n     * Example\\n     *\\n     * Stakes: [ Alice/20, Bob/10, Carl/40, Dave/25 ]\\n     * TotalStake: 95\\n     *\\n     * EpochDirectory:\\n     *\\n     *  |-----------|------|----------------|--------|\\n     *     Alice/20  Bob/30     Carl/70      Dave/95\\n     *\\n     * The amount of stake that a node will join a directory with is dependent on its\\n     * different capacity values. There are two distinct capacity values, one\\n     * calculated from the seeker power, and another from the minimum stake\\n     * proportion. The final staking amount will not exceed either capacities,\\n     * and in the case that the current total stake exceeds both, then the final\\n     * will be the minimum of the two values.\\n     */\\n    function joinNextDirectory(address stakee, uint256 seekerId) external onlyManager {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n\\n        uint256 nextEpochId = currentDirectory + 1;\\n\\n        uint256 totalStake = _stakingManager.getStakeeTotalManagedStake(stakee);\\n        if (totalStake == 0) {\\n            revert NoStakeToJoinEpoch();\\n        }\\n\\n        // staking capacity based on seeker power\\n        uint256 seekerStakingCapacity = _stakingManager.calculateCapacityFromSeekerPower(seekerId);\\n\\n        // staking capacity based on the min staking proportion constant\\n        uint256 minProportionStakingCapacity = _stakingManager.calculateCapacityFromMinStakingProportion(stakee);\\n\\n        uint256 joiningStake;\\n        if (totalStake > seekerStakingCapacity && totalStake > minProportionStakingCapacity) {\\n            joiningStake = Math.min(seekerStakingCapacity, minProportionStakingCapacity);\\n        } else if (totalStake > seekerStakingCapacity) {\\n            joiningStake = seekerStakingCapacity;\\n        } else if (totalStake > minProportionStakingCapacity) {\\n            joiningStake = minProportionStakingCapacity;\\n        } else { // uncapped\\n            joiningStake = totalStake;\\n        }\\n\\n        if (joiningStake == 0) {\\n            revert NoJoiningStakeToJoinEpoch();\\n        }\\n\\n        if (directories[nextEpochId].stakes[stakee] > 0) {\\n            revert StakeeAlreadyJoinedEpoch();\\n        }\\n\\n        uint256 nextBoundary = directories[nextEpochId].totalStake + joiningStake;\\n\\n        directories[nextEpochId].entries.push(DirectoryEntry(stakee, nextBoundary));\\n        directories[nextEpochId].stakes[stakee] = joiningStake;\\n        directories[nextEpochId].totalStake = nextBoundary;\\n    }\\n\\n    /**\\n     * @notice Call this to perform a stake-weighted scan to find the Node assigned\\n     * to the given point of the current directory.\\n     * @param point The point, which will usually be a hash of a public key.\\n     */\\n    function scan(uint128 point) external view returns (address stakee) {\\n        return _scan(point, currentDirectory);\\n    }\\n\\n    /**\\n     * @notice Call this to perform a stake-weighted scan to find the Node assigned\\n     * to the given point of the requested directory.\\n     * @param point The point, which will usually be a hash of a public key.\\n     * @param epochId The epoch id associated with the directory to scan.\\n     */\\n    function scanWithEpochId(\\n        uint128 point,\\n        uint256 epochId\\n    ) external view returns (address stakee) {\\n        return _scan(point, epochId);\\n    }\\n\\n    /**\\n     * @notice Call this to perform a stake-weighted scan to find the Node assigned\\n     * to the given point of the requested directory (internal).\\n     * @dev The current implementation will perform a binary search through\\n     * the directory. This can allow gas costs to be low if this needs to be\\n     * used in a transaction.\\n     * @param point The point, which will usually be a hash of a public key.\\n     * @param epochId The epoch id associated with the directory to scan.\\n     */\\n    function _scan(uint128 point, uint256 epochId) internal view returns (address stakee) {\\n        uint256 entryLength = directories[epochId].entries.length;\\n\\n        if (entryLength == 0) {\\n            return address(0);\\n        }\\n\\n        // Staking all the Sylo would only be 94 bits, so multiplying this with\\n        // a uint128 cannot overflow a uint256.\\n        uint256 expectedVal = (directories[epochId].totalStake * uint256(point)) >> 128;\\n\\n        uint256 left;\\n        uint256 right = entryLength - 1;\\n\\n        // perform a binary search through the directory\\n        uint256 lower;\\n        uint256 upper;\\n        uint256 index;\\n\\n        while (left <= right) {\\n            index = (left + right) >> 1;\\n\\n            lower = index == 0 ? 0 : directories[epochId].entries[index - 1].boundary;\\n            upper = directories[epochId].entries[index].boundary;\\n\\n            if (expectedVal >= lower && expectedVal < upper) {\\n                return directories[epochId].entries[index].stakee;\\n            } else if (expectedVal < lower) {\\n                right = index - 1;\\n            } else {\\n                // expectedVal >= upper\\n                left = index + 1;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieve the total stake a Node has for the directory in the\\n     * specified epoch.\\n     * @param epochId The ID of the epoch.\\n     * @param stakee The address of the Node.\\n     * @return The amount of stake the Node has for the given directory in SOLO.\\n     */\\n    function getTotalStakeForStakee(\\n        uint256 epochId,\\n        address stakee\\n    ) external view returns (uint256) {\\n        return directories[epochId].stakes[stakee];\\n    }\\n\\n    /**\\n     * @notice Retrieve the total stake for a directory in the specified epoch, which\\n     * will be the sum of the stakes for all Nodes participating in that epoch.\\n     * @param epochId The ID of the epoch.\\n     * @return The total amount of stake in SOLO.\\n     */\\n    function getTotalStake(uint256 epochId) external view returns (uint256) {\\n        return directories[epochId].totalStake;\\n    }\\n\\n    /**\\n     * @notice Retrieve all entries for a directory in a specified epoch.\\n     * @return An array of all the directory entries.\\n     */\\n    function getEntries(\\n        uint256 epochId\\n    ) external view returns (address[] memory, uint256[] memory) {\\n        uint256 entryLength = directories[epochId].entries.length;\\n\\n        address[] memory stakees = new address[](entryLength);\\n        uint256[] memory boundaries = new uint256[](entryLength);\\n\\n        DirectoryEntry memory entry;\\n        DirectoryEntry[] memory entries = directories[epochId].entries;\\n\\n        for (uint256 i; i < entryLength; ++i) {\\n            entry = entries[i];\\n            stakees[i] = entry.stakee;\\n            boundaries[i] = entry.boundary;\\n        }\\n        return (stakees, boundaries);\\n    }\\n}\\n\",\"keccak256\":\"0x98a344ba0403e7c5e92fe89a67799ec6583767bfa82a76e66c3b6e84ce519e59\",\"license\":\"Apache-2.0\"},\"contracts/staking/StakingManager.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\n\\nimport \\\"../SyloToken.sol\\\";\\nimport \\\"../libraries/SyloUtils.sol\\\";\\nimport \\\"../SeekerPowerOracle.sol\\\";\\nimport \\\"../epochs/EpochsManager.sol\\\";\\nimport \\\"../payments/ticketing/RewardsManager.sol\\\";\\nimport \\\"../interfaces/staking/IStakingManager.sol\\\";\\n\\n/**\\n * @notice Manages stakes and delegated stakes for Nodes. Holding\\n * staked Sylo is necessary for a Node to participate in the\\n * Sylo Network. The stake is used in stake-weighted scan function,\\n * and delegated stakers are rewarded on a pro-rata basis.\\n */\\ncontract StakingManager is IStakingManager, Initializable, Ownable2StepUpgradeable, ERC165 {\\n    /** ERC 20 compatible token we are dealing with */\\n    IERC20 public _token;\\n\\n    /**\\n     * @notice Rewards Manager contract. Any changes to stake will automatically\\n     * trigger a claim to any outstanding rewards.\\n     */\\n    RewardsManager public _rewardsManager;\\n\\n    EpochsManager public _epochsManager;\\n\\n    SeekerPowerOracle public _seekerPowerOracle;\\n\\n    /**\\n     * @notice Tracks the managed stake for every Node.\\n     */\\n    mapping(address => Stake) public stakes;\\n\\n    /** @notice Tracks overall total stake held by this contract */\\n    uint256 public totalManagedStake;\\n\\n    /**\\n     * @notice Tracks funds that are in the process of being unlocked. This\\n     * is indexed by a key that hashes both the address of the staked Node and\\n     * the address of the staker.\\n     */\\n    mapping(bytes32 => Unlock) public unlockings;\\n\\n    /**\\n     * @notice The number of blocks a user must wait after calling \\\"unlock\\\"\\n     * before they can withdraw their stake\\n     */\\n    uint256 public unlockDuration;\\n\\n    /**\\n     * @notice Minimum amount of stake that a Node needs to stake\\n     * against itself in order to participate in the network. This is\\n     * represented as a percentage of the Node's total stake, where\\n     * the value is a ratio of 10000.\\n     */\\n    uint32 public minimumStakeProportion;\\n\\n    /**\\n     * @notice The multiplier used in determining a Seeker's staking\\n     * capacity based on its power level.\\n     */\\n    uint256 public seekerPowerMultiplier;\\n\\n    event UnlockDurationUpdated(uint256 unlockDuration);\\n    event MinimumStakeProportionUpdated(uint256 minimumStakeProportion);\\n\\n    error NoStakeToUnlock();\\n    error StakeNotYetUnlocked();\\n    error CannotStakeZeroAmount();\\n    error CannotUnlockZeroAmount();\\n    error TokenCannotBeZeroAddress();\\n    error StakeeCannotBeZeroAddress();\\n    error UnlockDurationCannotBeZero();\\n    error CannotCancelUnlockZeroAmount();\\n    error CannotUnlockMoreThanStaked(uint256 stakeAmount, uint256 unlockAmount);\\n    error StakeCapacityReached(uint256 maxCapacity, uint256 currentCapacity);\\n    error SeekerPowerNotRegistered(uint256 seekerId);\\n\\n    function initialize(\\n        IERC20 token,\\n        RewardsManager rewardsManager,\\n        EpochsManager epochsManager,\\n        SeekerPowerOracle seekerPowerOracle,\\n        uint256 _unlockDuration,\\n        uint32 _minimumStakeProportion,\\n        uint256 _seekerPowerMultiplier\\n    ) external initializer {\\n        if (address(token) == address(0)) {\\n            revert TokenCannotBeZeroAddress();\\n        }\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"RewardsManager\\\",\\n            address(rewardsManager),\\n            type(IRewardsManager).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"EpochsManager\\\",\\n            address(epochsManager),\\n            type(IEpochsManager).interfaceId\\n        );\\n\\n        SyloUtils.validateContractInterface(\\n            \\\"SeekerPowerOracle\\\",\\n            address(seekerPowerOracle),\\n            type(ISeekerPowerOracle).interfaceId\\n        );\\n\\n        if (_unlockDuration == 0) {\\n            revert UnlockDurationCannotBeZero();\\n        }\\n\\n        Ownable2StepUpgradeable.__Ownable2Step_init();\\n\\n        _token = token;\\n        _rewardsManager = rewardsManager;\\n        _epochsManager = epochsManager;\\n        _seekerPowerOracle = seekerPowerOracle;\\n        unlockDuration = _unlockDuration;\\n        minimumStakeProportion = _minimumStakeProportion;\\n        seekerPowerMultiplier = _seekerPowerMultiplier;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract implements the interface defined by\\n     * `interfaceId` from ERC165.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IStakingManager).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Sets the unlock duration for stakes. Only callable by\\n     * the owner.\\n     * @param _unlockDuration The unlock duration in number of blocks.\\n     */\\n    function setUnlockDuration(uint256 _unlockDuration) external onlyOwner {\\n        if (_unlockDuration == 0) {\\n            revert UnlockDurationCannotBeZero();\\n        }\\n\\n        unlockDuration = _unlockDuration;\\n        emit UnlockDurationUpdated(_unlockDuration);\\n    }\\n\\n    /**\\n     * @notice Sets the minimum stake proportion for Nodes. Only callable by\\n     * the owner.\\n     * @param _minimumStakeProportion The minimum stake proportion in SOLO.\\n     */\\n    function setMinimumStakeProportion(uint32 _minimumStakeProportion) external onlyOwner {\\n        minimumStakeProportion = _minimumStakeProportion;\\n        emit MinimumStakeProportionUpdated(_minimumStakeProportion);\\n    }\\n\\n    /**\\n     * @notice Called by Nodes and delegated stakers to add stake.\\n     * This function will fail under the following conditions:\\n     *   - If the Node address is invalid\\n     *   - If the specified stake value is zero\\n     *   - If the additional stake causes the Node to fail to meet the\\n     *     minimum stake proportion requirement.\\n     * @param amount The amount of stake to add in SOLO.\\n     * @param stakee The address of the staked Node.\\n     */\\n    function addStake(uint256 amount, address stakee) external {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n        if (amount == 0) {\\n            revert CannotStakeZeroAmount();\\n        }\\n\\n        _addStake(amount, stakee);\\n        SafeERC20.safeTransferFrom(_token, msg.sender, address(this), amount);\\n    }\\n\\n    function _addStake(uint256 amount, address stakee) internal {\\n        // automatically move any pending rewards generated by their existing stake\\n        _rewardsManager.updatePendingRewards(stakee, msg.sender);\\n\\n        uint256 currentEpochId = _epochsManager.currentIteration();\\n\\n        Stake storage stake = stakes[stakee];\\n\\n        uint256 currentStake = getCurrentStakerAmount(stakee, msg.sender);\\n\\n        stake.stakeEntries[msg.sender] = StakeEntry(\\n            currentStake + amount,\\n            block.number,\\n            currentEpochId\\n        );\\n\\n        stake.totalManagedStake = stake.totalManagedStake + amount;\\n        totalManagedStake = totalManagedStake + amount;\\n    }\\n\\n    /**\\n     * @notice Call this function to begin the unlocking process. Calling this\\n     * will trigger an automatic claim of any outstanding staking rewards. Any\\n     * stake that was already in the unlocking phase will have the specified\\n     * amount added to it, and its duration refreshed. This function will fail\\n     * under the following conditions:\\n     *   - If no stake exists for the caller\\n     *   - If the unlock amount is zero\\n     *   - If the unlock amount is more than what is staked\\n     * Note: If calling as a Node, this function will *not* revert if it causes\\n     * the Node to fail to meet the minimum stake proportion. However it will still\\n     * prevent the Node from participating in the network until the minimum is met\\n     * again.\\n     * @param amount The amount of stake to unlock in SOLO.\\n     * @param stakee The address of the staked Node.\\n     */\\n    function unlockStake(uint256 amount, address stakee) external returns (uint256) {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n        if (amount == 0) {\\n            revert CannotUnlockZeroAmount();\\n        }\\n\\n        uint256 currentStake = getCurrentStakerAmount(stakee, msg.sender);\\n\\n        if (currentStake == 0) {\\n            revert NoStakeToUnlock();\\n        }\\n        if (currentStake < amount) {\\n            revert CannotUnlockMoreThanStaked(currentStake, amount);\\n        }\\n\\n        // automatically move any pending rewards generated by their existing stake\\n        _rewardsManager.updatePendingRewards(stakee, msg.sender);\\n\\n        uint256 currentEpochId = _epochsManager.currentIteration();\\n\\n        Stake storage stake = stakes[stakee];\\n\\n        stake.stakeEntries[msg.sender] = StakeEntry(\\n            currentStake - amount,\\n            block.number,\\n            currentEpochId\\n        );\\n\\n        stake.totalManagedStake = stake.totalManagedStake - amount;\\n        totalManagedStake = totalManagedStake - amount;\\n\\n        bytes32 key = getKey(stakee, msg.sender);\\n\\n        // Keep track of when the stake can be withdrawn\\n        Unlock storage unlock = unlockings[key];\\n\\n        uint256 unlockAt = block.number + unlockDuration;\\n        if (unlock.unlockAt < unlockAt) {\\n            unlock.unlockAt = unlockAt;\\n        }\\n\\n        unlock.amount = unlock.amount + amount;\\n\\n        return unlockAt;\\n    }\\n\\n    /**\\n     * @notice Call this function to withdraw stake that has finished unlocking.\\n     * This will fail if the stake has not yet unlocked.\\n     * @param stakee The address of the staked Node.\\n     */\\n    function withdrawStake(address stakee) external {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n\\n        bytes32 key = getKey(stakee, msg.sender);\\n\\n        Unlock storage unlock = unlockings[key];\\n\\n        if (unlock.unlockAt >= block.number) {\\n            revert StakeNotYetUnlocked();\\n        }\\n\\n        uint256 amount = unlock.amount;\\n\\n        delete unlockings[key];\\n\\n        SafeERC20.safeTransfer(_token, msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Call this function to cancel any stake that is in the process\\n     * of unlocking. As this essentially adds back stake to the Node, this\\n     * will trigger an automatic claim of any outstanding staking rewards.\\n     * If the specified amount to cancel is greater than the stake that is\\n     * currently being unlocked, it will cancel the maximum stake possible.\\n     * @param amount The amount of unlocking stake to cancel in SOLO.\\n     * @param stakee The address of the staked Node.\\n     */\\n    function cancelUnlocking(uint256 amount, address stakee) external {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n        if (amount == 0) {\\n            revert CannotCancelUnlockZeroAmount();\\n        }\\n\\n        bytes32 key = getKey(stakee, msg.sender);\\n\\n        Unlock storage unlock = unlockings[key];\\n\\n        if (amount >= unlock.amount) {\\n            amount = unlock.amount;\\n            delete unlockings[key];\\n        } else {\\n            unlock.amount = unlock.amount - amount;\\n        }\\n\\n        _addStake(amount, stakee);\\n    }\\n\\n    /**\\n     * @notice This function determines the staking capacity of\\n     * a Seeker based on its power level. The method will revert if\\n     * the Seeker's power level has not been registered with the oracle.\\n     *\\n     * Currently the algorithm is as follows:\\n     *    staking_capacity = seeker_power * seeker_power_multiplier;\\n     */\\n    function calculateCapacityFromSeekerPower(uint256 seekerId) external view returns (uint256) {\\n        uint256 seekerPower = _seekerPowerOracle.getSeekerPower(seekerId);\\n        if (seekerPower == 0) {\\n            revert SeekerPowerNotRegistered(seekerId);\\n        }\\n\\n        // If the Seeker Power is already\\n        // at the maximum sylo, then we just return the max sylo value directly.\\n        if (seekerPower >= SyloUtils.MAX_SYLO) {\\n            return SyloUtils.MAX_SYLO;\\n        }\\n\\n        uint256 capacity = seekerPower * seekerPowerMultiplier;\\n\\n        return capacity > SyloUtils.MAX_SYLO ? SyloUtils.MAX_SYLO : capacity;\\n    }\\n\\n    /**\\n     * @notice This function can be used to a determine a Node's staking capacity,\\n     * based on the minimum stake proportion constant.\\n     * @param stakee The address of the staked Node.\\n     */\\n    function calculateCapacityFromMinStakingProportion(address stakee) public view returns (uint256) {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n\\n        Stake storage stake = stakes[stakee];\\n\\n        uint256 currentlyOwnedStake = stake.stakeEntries[stakee].amount;\\n        return (currentlyOwnedStake * SyloUtils.PERCENTAGE_DENOMINATOR) /\\n            minimumStakeProportion;\\n    }\\n\\n    /**\\n     * @notice This function should be called by clients to determine how much\\n     * additional delegated stake can be allocated to a Node via an addStake or\\n     * cancelUnlocking call. This is useful to avoid a revert due to\\n     * the minimum stake proportion requirement not being met from the additional stake.\\n     * @param stakee The address of the staked Node.\\n     */\\n    function calculateMaxAdditionalDelegatedStake(address stakee) external view returns (uint256) {\\n        uint256 totalMaxStake = calculateCapacityFromMinStakingProportion(stakee);\\n\\n        Stake storage stake = stakes[stakee];\\n\\n        if (totalMaxStake < stake.totalManagedStake) {\\n            revert StakeCapacityReached(totalMaxStake, stake.totalManagedStake);\\n        }\\n\\n        return totalMaxStake - stake.totalManagedStake;\\n    }\\n\\n    /**\\n     * @notice Retrieve the key used to index a stake entry. The key is a hash\\n     * which takes both address of the Node and the staker as input.\\n     * @param stakee The address of the staked Node.\\n     * @param staker The address of the staker.\\n     * @return A byte-array representing the key.\\n     */\\n    function getKey(address stakee, address staker) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(stakee, staker));\\n    }\\n\\n    /**\\n     * @notice Retrieve the total stake being managed by this contract.\\n     * @return The total amount of managed stake in SOLO.\\n     */\\n    function getTotalManagedStake() external view returns (uint256) {\\n        return totalManagedStake;\\n    }\\n\\n    /**\\n     * @notice Retrieve a stake entry.\\n     * @param stakee The address of the staked Node.\\n     * @param staker The address of the staker.\\n     * @return The stake entry.\\n     */\\n    function getStakeEntry(\\n        address stakee,\\n        address staker\\n    ) external view returns (StakeEntry memory) {\\n        return stakes[stakee].stakeEntries[staker];\\n    }\\n\\n    /**\\n     * @notice Retrieve the total amount of SOLO staked against a Node.\\n     * @param stakee The address of the staked Node.\\n     * @return The amount of staked SOLO.\\n     */\\n    function getStakeeTotalManagedStake(address stakee) external view returns (uint256) {\\n        return stakes[stakee].totalManagedStake;\\n    }\\n\\n    /**\\n     * @notice Check if a Node is meeting the minimum stake proportion requirement.\\n     * @param stakee The address of the staked Node.\\n     * @return True if the Node is meeting minimum stake proportion requirement.\\n     */\\n    function checkMinimumStakeProportion(address stakee) public view returns (bool) {\\n        if (stakee == address(0)) {\\n            revert StakeeCannotBeZeroAddress();\\n        }\\n\\n        Stake storage stake = stakes[stakee];\\n\\n        uint256 currentlyOwnedStake = stake.stakeEntries[stakee].amount;\\n        uint32 ownedStakeProportion = SyloUtils.asPerc(\\n            SafeCast.toUint128(currentlyOwnedStake),\\n            stake.totalManagedStake\\n        );\\n\\n        return ownedStakeProportion >= minimumStakeProportion;\\n    }\\n\\n    /**\\n     * @notice Retrieve the current amount of SOLO staked against a Node by\\n     * a specified staker.\\n     * @param stakee The address of the staked Node.\\n     * @param staker The address of the staker.\\n     * @return The amount of staked SOLO.\\n     */\\n    function getCurrentStakerAmount(address stakee, address staker) public view returns (uint256) {\\n        return stakes[stakee].stakeEntries[staker].amount;\\n    }\\n}\\n\",\"keccak256\":\"0x039e692a4a3a670977e78ef7145a43d0bc00e48387fafd4f527b60fbb6966628\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612fc5806100206000396000f3fe608060405234801561001057600080fd5b50600436106102065760003560e01c80638a1fcd601161011a578063cdba7342116100ad578063eb6d17891161007c578063eb6d178914610478578063ebd807861461048b578063ecd0c0c31461049e578063f2fde38b146104b1578063fc7e286d146104c457600080fd5b8063cdba734214610439578063d088a2311461044c578063dd90076914610454578063e30c39781461046757600080fd5b8063b24651c4116100e9578063b24651c4146103ed578063c3b6f72614610400578063c70f1a8c14610413578063caf3b7fd1461042657600080fd5b80638a1fcd60146103ad5780638da5cb5b146103b6578063a40b209f146103c7578063ac908b6e146103da57600080fd5b806343c8d8a21161019d57806372b0d90c1161016c57806372b0d90c1461036457806378a9c63d1461037757806379ba50971461038a5780637d6babb4146103925780637ddc62c11461039a57600080fd5b806343c8d8a2146102fe57806359a515ba1461031157806367653e5514610334578063715018a61461035c57600080fd5b8063295ca02d116101d9578063295ca02d146102975780632c4ab445146102b8578063344dd6e4146102e35780633ccfd60b146102f657600080fd5b806301ffc9a71461020b5780630ab2502214610244578063169e1ca81461026f5780631f4c747e14610284575b600080fd5b61022f610219366004612580565b6001600160e01b03191663567cd4c960e11b1490565b60405190151581526020015b60405180910390f35b609c54610257906001600160a01b031681565b6040516001600160a01b03909116815260200161023b565b61028261027d3660046125bf565b61050e565b005b609e54610257906001600160a01b031681565b6102aa6102a5366004612713565b6105bd565b60405190815260200161023b565b6102cb6102c636600461272f565b61062e565b6040516001600160801b03909116815260200161023b565b6102826102f1366004612751565b610786565b610282610ab6565b61028261030c36600461285e565b610ac1565b61022f61031f366004612905565b60a16020526000908152604090205460ff1681565b61034761034236600461291e565b610c65565b6040805192835260208301919091520161023b565b61028261105e565b610282610372366004612979565b611070565b610282610385366004612996565b611134565b6102826112d4565b6102aa61134e565b609b54610257906001600160a01b031681565b6102aa609f5481565b6033546001600160a01b0316610257565b6102aa6103d5366004612abf565b6113c9565b6102aa6103e8366004612b09565b611684565b609854610257906001600160a01b031681565b609954610257906001600160a01b031681565b609a54610257906001600160a01b031681565b609d54610257906001600160a01b031681565b6102826104473660046125bf565b6116ec565b61028261179c565b610282610462366004612905565b6117da565b6065546001600160a01b0316610257565b6102aa61048636600461272f565b61183e565b61022f610499366004612bb3565b611890565b609754610257906001600160a01b031681565b6102826104bf366004612979565b6118ee565b6104f36104d2366004612979565b60a06020526000908152604090208054600182015460029092015490919083565b6040805193845260208401929092529082015260600161023b565b8160000361052f5760405163adfd6eb360e01b815260040160405180910390fd5b6001600160a01b03811661055657604051633423ddb360e11b815260040160405180910390fd5b6001600160a01b038116600090815260a06020526040902060028101541561059157604051631c98f45d60e01b815260040160405180910390fd5b805461059e908490612c48565b81556097546105b8906001600160a01b031633308661195f565b505050565b805160208083015151604080850151606080870151608088015184519687019790975293811b6001600160601b0319908116938601939093521b1660548301526068820152608881019190915260009060a8015b604051602081830303815290604052805190602001209050919050565b609c54604051635e05e35d60e11b81526004810184905260009182916001600160a01b039091169063bc0bc6ba9060240161012060405180830381865afa15801561067d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106a19190612c8b565b80519091506000036106c65760405163a756193360e01b815260040160405180910390fd5b80518310806106e85750600081604001511180156106e8575080604001518310155b15610706576040516339e9ad8d60e11b815260040160405180910390fd5b60006107128443612d20565b9050816101000151811061072b57600092505050610780565b600061073f8360c0015184608001516119d0565b9050600083610100015183836107559190612d33565b61075f9190612d4a565b905061076a81611a00565b8460c001516107799190612d6c565b9450505050505b92915050565b600054610100900460ff16158080156107a65750600054600160ff909116105b806107c05750303b1580156107c0575060005460ff166001145b6108285760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6000805460ff19166001179055801561084b576000805461ff0019166101001790555b6001600160a01b038a1661087257604051635f5d339960e01b815260040160405180910390fd5b6108a66040518060400160405280600a8152602001695265676973747269657360b01b8152508a637ccc541d60e11b611a6d565b6108de6040518060400160405280600e81526020016d29ba30b5b4b733a6b0b730b3b2b960911b815250896303e0261b60e41b611a6d565b610911604051806040016040528060098152602001684469726563746f727960b81b81525088638a5d64cd60e01b611a6d565b6109486040518060400160405280600d81526020016c22b837b1b439a6b0b730b3b2b960991b8152508763078a0a4b60e41b611a6d565b6109806040518060400160405280600e81526020016d2932bbb0b93239a6b0b730b3b2b960911b81525086631ed895ad60e11b611a6d565b6109bc60405180604001604052806012815260200171417574686f72697a65644163636f756e747360701b815250856337e592f160e21b611a6d565b816000036109dd57604051632d8ef94560e11b815260040160405180910390fd5b6109e5611b71565b609780546001600160a01b03199081166001600160a01b038d8116919091179092556098805482168c84161790556099805482168b8416179055609a805482168a8416179055609c80548216898416179055609b80548216888416179055609d80548216878416179055609e8054909116918516919091179055609f8290558015610aaa576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050505050565b610abf33611070565b565b609c54604051635e05e35d60e11b8152883560048201526000916001600160a01b03169063bc0bc6ba9060240161012060405180830381865afa158015610b0c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b309190612c8b565b90504388608001351115610b5a576040516001623a160d60e21b0319815260040160405180910390fd5b6000610b79610b6e368b90038b018b612713565b888a89898989610c65565b600081815260a160205260408120805460ff19166001179055609a5491935091506001600160a01b0316631bdcc9ad8b35610bba60808e0160608f01612979565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b03166024820152604401602060405180830381865afa158015610c04573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c289190612d93565b905080600003610c4e57604051637f6cbf1960e11b81528a35600482015260240161081f565b610aaa838b610c6060208c018c612979565b611ba0565b60208701515160009081906001600160a01b0316610c965760405163091e31fd60e31b815260040160405180910390fd5b6000610ca560208a018a612979565b6001600160a01b031603610ccc57604051635ff51db760e11b815260040160405180910390fd5b60408901516001600160a01b0316610cf75760405163cab78a2360e01b815260040160405180910390fd5b609e546000906001600160a01b0316634dde5a44610d1860208c018c612979565b6040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602401602060405180830381865afa158015610d5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d809190612dac565b90506001600160a01b038116610dc257610d9d60208a018a612979565b60405163149948a160e31b81526001600160a01b03909116600482015260240161081f565b610dcb8a6105bd565b92508281604051602001610df692919091825260601b6001600160601b031916602082015260340190565b60408051601f198184030181529181528151602092830120600081815260a190935291205490925060ff1615610e3f576040516301faedd760e61b815260040160405180910390fd5b8960800151610e528b606001518a61183e565b14610e705760405163bfec4b7960e01b815260040160405180910390fd5b610e828a602001518b60600151611c44565b610e9f57604051632616fe7d60e11b815260040160405180910390fd5b610ebb610eb1368b90038b018b612dc9565b8b60600151611c44565b610ed8576040516354c4763f60e01b815260040160405180910390fd5b610f1e8a6020015188888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250889250611ce4915050565b610f3b576040516319ad5a6d60e21b815260040160405180910390fd5b610f8b610f4d368b90038b018b612dc9565b86868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250889250611ce4915050565b610fa857604051639bce429160e01b815260040160405180910390fd5b61103487878080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f8b018190048102820181019092528981529250899150889081908401838280828437600081840152601f19601f820116905080830192505050505050508c600001518d606001518c611890565b61105157604051630554a83160e31b815260040160405180910390fd5b5097509795505050505050565b611066611d62565b610abf6000611dbc565b33600090815260a0602052604081206040805160608101825282548152600183015460208201526002909201549082018190529091506000036110c65760405163065bea4960e21b815260040160405180910390fd5b438160400151106110ea576040516366af725560e01b815260040160405180910390fd5b602081015181516000916110fd91612c48565b33600090815260a06020526040812081815560018101829055600201556097549091506105b8906001600160a01b03168483611dd5565b609c54604051635e05e35d60e11b8152873560048201526000916001600160a01b03169063bc0bc6ba9060240161012060405180830381865afa15801561117f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111a39190612c8b565b9050438760c0013511156111cd576040516001623a160d60e21b0319815260040160405180910390fd5b60006111eb6111e1368a90038a018a612b09565b88888888886113c9565b600081815260a160205260408120805460ff19166001179055609a54919250906001600160a01b0316631bdcc9ad8a3561122b60c08d0160a08e01612979565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b03166024820152604401602060405180830381865afa158015611275573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112999190612d93565b9050806000036112bf57604051637f6cbf1960e11b81528935600482015260240161081f565b6112c9838a611e05565b505050505050505050565b60655433906001600160a01b031681146113425760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b606482015260840161081f565b61134b81611dbc565b50565b33600090815260a060205260408120805415801561136e57506001810154155b1561138c57604051639c4e744360e01b815260040160405180910390fd5b6002810154156113af57604051631c98f45d60e01b815260040160405180910390fd5b609f546113bc9043612c48565b6002909101819055919050565b6020860151516000906001600160a01b03166113f85760405163091e31fd60e31b815260040160405180910390fd5b6040870151516001600160a01b031661142457604051635ff51db760e11b815260040160405180910390fd5b60608701516001600160a01b031661144f5760405163cab78a2360e01b815260040160405180910390fd5b61145887611684565b600081815260a1602052604090205490915060ff161561148b576040516301faedd760e61b815260040160405180910390fd5b8660a0015161149e88608001518861183e565b146114bc5760405163bfec4b7960e01b815260040160405180910390fd5b6114ce87602001518860800151611c44565b6114eb57604051632616fe7d60e11b815260040160405180910390fd5b6114fd87604001518860800151611c44565b61151a576040516354c4763f60e01b815260040160405180910390fd5b611560876020015186868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250869250611ce4915050565b61157d576040516319ad5a6d60e21b815260040160405180910390fd5b6115c3876040015184848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250869250611ce4915050565b6115e057604051639bce429160e01b815260040160405180910390fd5b61165d85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f89018190048102820181019092528781529250879150869081908401838280828437600092019190915250508b5160808d015190925090508a611890565b61167a57604051630554a83160e31b815260040160405180910390fd5b9695505050505050565b80516020808301515160408085015151606080870151608088015160a089015185519788019890985294821b6001600160601b03199081169487019490945291811b831660548601521b166068830152607c820152609c81019190915260009060bc01610611565b8160000361170d5760405163ea50132f60e01b815260040160405180910390fd5b6001600160a01b03811661173457604051633423ddb360e11b815260040160405180910390fd5b6001600160a01b038116600090815260a06020526040902060028101541561176f57604051631c98f45d60e01b815260040160405180910390fd5b82816001015461177f9190612c48565b60018201556097546105b8906001600160a01b031633308661195f565b33600090815260a06020526040812060028101549091036117d05760405163065bea4960e21b815260040160405180910390fd5b6000600290910155565b6117e2611d62565b8060000361180357604051632d8ef94560e11b815260040160405180910390fd5b609f8190556040518181527fbf6423edafc706e6ae214d98c485a52f610ee2f23148b43d546af3f8834c21b39060200160405180910390a150565b604080516020810184905290810182905260009060600160408051601f198184030181528282528051602091820120908301520160405160208183030381529060405280519060200120905092915050565b60008061189d858561062e565b6001600160801b03169050600081608083901b179050808888866040516020016118c993929190612e09565b60408051601f1981840301815291905280516020909101201098975050505050505050565b6118f6611d62565b606580546001600160a01b0383166001600160a01b031990911681179091556119276033546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b6040516001600160a01b03808516602483015283166044820152606481018290526119ca9085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611eb6565b50505050565b6000620186a06119ef63ffffffff84166001600160801b038616612d33565b6119f99190612d4a565b9392505050565b60006001600160801b03821115611a695760405162461bcd60e51b815260206004820152602760248201527f53616665436173743a2076616c756520646f65736e27742066697420696e20316044820152663238206269747360c81b606482015260840161081f565b5090565b8251600003611a8f5760405163d1fc12f760e01b815260040160405180910390fd5b6001600160a01b038216611ab6578260405161f56160eb1b815260040161081f9190612e6a565b6001600160e01b03198116611ade5760405163308c995160e01b815260040160405180910390fd5b6040516301ffc9a760e01b81526001600160e01b0319821660048201526001600160a01b038316906301ffc9a790602401602060405180830381865afa158015611b2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b509190612e7d565b6105b8578281604051633f8ccd3b60e21b815260040161081f929190612e9f565b600054610100900460ff16611b985760405162461bcd60e51b815260040161081f90612eca565b610abf611f8b565b6000611bbf8460208501611bba6080870160608801612979565b611fbb565b9050611bd16040840160208501612979565b6001600160a01b0316611bea6080850160608601612979565b604080516001600160a01b038681168252608088013560208301529181018590529116908535907f04562f4c0ee54b401e8fcaafa7daa175963d9bb7a07297633221dc08b1d57b0f9060600160405180910390a450505050565b60208201516000906001600160a01b0316611c6157506001610780565b609d548351602085015160405163c346893b60e01b81526000936001600160a01b03169263c346893b92611c9b9286908990600401612f2b565b602060405180830381865afa158015611cb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cdc9190612e7d565b949350505050565b602083015160009081906001600160a01b031615611d0757506020840151611d0b565b5083515b7f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c849052603c90206001600160a01b038216611d4e8287612098565b6001600160a01b0316149695505050505050565b6033546001600160a01b03163314610abf5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161081f565b606580546001600160a01b031916905561134b816120bc565b6040516001600160a01b0383166024820152604481018290526105b890849063a9059cbb60e01b90606401611993565b6000611e1f8360208401611bba60c0860160a08701612979565b9050611e316040830160208401612979565b6001600160a01b0316611e4a60c0840160a08501612979565b6001600160a01b031683357f7d274bdf94856b1ec309b530c7bf991ea808eb7782afef762e28cce446178907611e866080870160608801612979565b604080516001600160a01b03909216825260c08801356020830152810186905260600160405180910390a4505050565b6000611f0b826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b031661210e9092919063ffffffff16565b9050805160001480611f2c575080806020019051810190611f2c9190612e7d565b6105b85760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b606482015260840161081f565b600054610100900460ff16611fb25760405162461bcd60e51b815260040161081f90612eca565b610abf33611dbc565b600080611fe8611fce6020860186612979565b6001600160a01b0316600090815260a06020526040902090565b9050600081600001548660a00151111561207e5750805461200a84838361211d565b6097546001830154612029916001600160a01b03169061dead90611dd5565b600060018301557f2ec87e1ff3f5b311fa539eb48a387afc2e82e11ac9919086426f16c1b35cfe8561205e6020870187612979565b6040516001600160a01b03909116815260200160405180910390a161208f565b5060a085015161208f84838361211d565b95945050505050565b60008060006120a785856121b4565b915091506120b4816121f9565b509392505050565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6060611cdc8484600085612343565b815461212a908290612d20565b8255609754609b54612149916001600160a01b03908116911683611dd5565b609b546040516340768fd360e01b81526001600160a01b03858116600483015260248201849052909116906340768fd390604401600060405180830381600087803b15801561219757600080fd5b505af11580156121ab573d6000803e3d6000fd5b50505050505050565b60008082516041036121ea5760208301516040840151606085015160001a6121de8782858561241e565b945094505050506121f2565b506000905060025b9250929050565b600081600481111561220d5761220d612f15565b036122155750565b600181600481111561222957612229612f15565b036122765760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e61747572650000000000000000604482015260640161081f565b600281600481111561228a5761228a612f15565b036122d75760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e67746800604482015260640161081f565b60038160048111156122eb576122eb612f15565b0361134b5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b606482015260840161081f565b6060824710156123a45760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b606482015260840161081f565b600080866001600160a01b031685876040516123c09190612f73565b60006040518083038185875af1925050503d80600081146123fd576040519150601f19603f3d011682016040523d82523d6000602084013e612402565b606091505b5091509150612413878383876124e2565b979650505050505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561245557506000905060036124d9565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa1580156124a9573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166124d2576000600192509250506124d9565b9150600090505b94509492505050565b6060831561255157825160000361254a576001600160a01b0385163b61254a5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161081f565b5081611cdc565b611cdc83838151156125665781518083602001fd5b8060405162461bcd60e51b815260040161081f9190612e6a565b60006020828403121561259257600080fd5b81356001600160e01b0319811681146119f957600080fd5b6001600160a01b038116811461134b57600080fd5b600080604083850312156125d257600080fd5b8235915060208301356125e4816125aa565b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b604051610120810167ffffffffffffffff81118282101715612629576126296125ef565b60405290565b60006040828403121561264157600080fd5b6040516040810181811067ffffffffffffffff82111715612664576126646125ef565b6040529050808235612675816125aa565b81526020830135612685816125aa565b6020919091015292915050565b600060c082840312156126a457600080fd5b60405160a0810181811067ffffffffffffffff821117156126c7576126c76125ef565b604052823581529050806126de846020850161262f565b602082015260608301356126f1816125aa565b806040830152506080830135606082015260a083013560808201525092915050565b600060c0828403121561272557600080fd5b6119f98383612692565b6000806040838503121561274257600080fd5b50508035926020909101359150565b60008060008060008060008060006101208a8c03121561277057600080fd5b893561277b816125aa565b985060208a013561278b816125aa565b975060408a013561279b816125aa565b965060608a01356127ab816125aa565b955060808a01356127bb816125aa565b945060a08a01356127cb816125aa565b935060c08a01356127db816125aa565b925060e08a01356127eb816125aa565b809250506101008a013590509295985092959850929598565b60006040828403121561281657600080fd5b50919050565b60008083601f84011261282e57600080fd5b50813567ffffffffffffffff81111561284657600080fd5b6020830191508360208285010111156121f257600080fd5b600080600080600080600087890361016081121561287b57600080fd5b60c081121561288957600080fd5b5087965060c088013595506128a18960e08a01612804565b945061012088013567ffffffffffffffff808211156128bf57600080fd5b6128cb8b838c0161281c565b90965094506101408a01359150808211156128e557600080fd5b506128f28a828b0161281c565b989b979a50959850939692959293505050565b60006020828403121561291757600080fd5b5035919050565b6000806000806000806000610160888a03121561293a57600080fd5b6129448989612692565b96506129538960c08a01612804565b9550610100880135945061012088013567ffffffffffffffff808211156128bf57600080fd5b60006020828403121561298b57600080fd5b81356119f9816125aa565b6000806000806000808688036101608112156129b157600080fd5b610100808212156129c157600080fd5b88975087013595505061012086013567ffffffffffffffff808211156129e657600080fd5b6129f28a838b0161281c565b9096509450610140890135915080821115612a0c57600080fd5b50612a1989828a0161281c565b979a9699509497509295939492505050565b60006101008284031215612a3e57600080fd5b60405160c0810181811067ffffffffffffffff82111715612a6157612a616125ef565b60405282358152905080612a78846020850161262f565b6020820152612a8a846060850161262f565b604082015260a0830135612a9d816125aa565b8060608301525060c0830135608082015260e083013560a08201525092915050565b6000806000806000806101608789031215612ad957600080fd5b612ae38888612a2b565b9550610100870135945061012087013567ffffffffffffffff808211156129e657600080fd5b60006101008284031215612b1c57600080fd5b6119f98383612a2b565b600082601f830112612b3757600080fd5b813567ffffffffffffffff80821115612b5257612b526125ef565b604051601f8301601f19908116603f01168101908282118183101715612b7a57612b7a6125ef565b81604052838152866020858801011115612b9357600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080600060a08688031215612bcb57600080fd5b853567ffffffffffffffff80821115612be357600080fd5b612bef89838a01612b26565b96506020880135915080821115612c0557600080fd5b50612c1288828901612b26565b959895975050505060408401359360608101359360809091013592509050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561078057610780612c32565b805163ffffffff81168114612c6f57600080fd5b919050565b80516001600160801b0381168114612c6f57600080fd5b60006101208284031215612c9e57600080fd5b612ca6612605565b825181526020830151602082015260408301516040820152612cca60608401612c5b565b6060820152612cdb60808401612c5b565b608082015260a083015160a0820152612cf660c08401612c74565b60c0820152612d0760e08401612c74565b60e0820152610100928301519281019290925250919050565b8181038181111561078057610780612c32565b808202811582820484141761078057610780612c32565b600082612d6757634e487b7160e01b600052601260045260246000fd5b500490565b6001600160801b03828116828216039080821115612d8c57612d8c612c32565b5092915050565b600060208284031215612da557600080fd5b5051919050565b600060208284031215612dbe57600080fd5b81516119f9816125aa565b600060408284031215612ddb57600080fd5b6119f9838361262f565b60005b83811015612e00578181015183820152602001612de8565b50506000910152565b60008451612e1b818460208901612de5565b845190830190612e2f818360208901612de5565b01928352505060200192915050565b60008151808452612e56816020860160208601612de5565b601f01601f19169290920160200192915050565b6020815260006119f96020830184612e3e565b600060208284031215612e8f57600080fd5b815180151581146119f957600080fd5b604081526000612eb26040830185612e3e565b905063ffffffff60e01b831660208301529392505050565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b038581168252841660208201526080810160018410612f6157634e487b7160e01b600052602160045260246000fd5b60408201939093526060015292915050565b60008251612f85818460208701612de5565b919091019291505056fea2646970667358221220df15c9ce639d482fafc3d321375e7ebc8cd7cfc4ec1c8617ea0c1d536d6c317e64736f6c63430008120033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102065760003560e01c80638a1fcd601161011a578063cdba7342116100ad578063eb6d17891161007c578063eb6d178914610478578063ebd807861461048b578063ecd0c0c31461049e578063f2fde38b146104b1578063fc7e286d146104c457600080fd5b8063cdba734214610439578063d088a2311461044c578063dd90076914610454578063e30c39781461046757600080fd5b8063b24651c4116100e9578063b24651c4146103ed578063c3b6f72614610400578063c70f1a8c14610413578063caf3b7fd1461042657600080fd5b80638a1fcd60146103ad5780638da5cb5b146103b6578063a40b209f146103c7578063ac908b6e146103da57600080fd5b806343c8d8a21161019d57806372b0d90c1161016c57806372b0d90c1461036457806378a9c63d1461037757806379ba50971461038a5780637d6babb4146103925780637ddc62c11461039a57600080fd5b806343c8d8a2146102fe57806359a515ba1461031157806367653e5514610334578063715018a61461035c57600080fd5b8063295ca02d116101d9578063295ca02d146102975780632c4ab445146102b8578063344dd6e4146102e35780633ccfd60b146102f657600080fd5b806301ffc9a71461020b5780630ab2502214610244578063169e1ca81461026f5780631f4c747e14610284575b600080fd5b61022f610219366004612580565b6001600160e01b03191663567cd4c960e11b1490565b60405190151581526020015b60405180910390f35b609c54610257906001600160a01b031681565b6040516001600160a01b03909116815260200161023b565b61028261027d3660046125bf565b61050e565b005b609e54610257906001600160a01b031681565b6102aa6102a5366004612713565b6105bd565b60405190815260200161023b565b6102cb6102c636600461272f565b61062e565b6040516001600160801b03909116815260200161023b565b6102826102f1366004612751565b610786565b610282610ab6565b61028261030c36600461285e565b610ac1565b61022f61031f366004612905565b60a16020526000908152604090205460ff1681565b61034761034236600461291e565b610c65565b6040805192835260208301919091520161023b565b61028261105e565b610282610372366004612979565b611070565b610282610385366004612996565b611134565b6102826112d4565b6102aa61134e565b609b54610257906001600160a01b031681565b6102aa609f5481565b6033546001600160a01b0316610257565b6102aa6103d5366004612abf565b6113c9565b6102aa6103e8366004612b09565b611684565b609854610257906001600160a01b031681565b609954610257906001600160a01b031681565b609a54610257906001600160a01b031681565b609d54610257906001600160a01b031681565b6102826104473660046125bf565b6116ec565b61028261179c565b610282610462366004612905565b6117da565b6065546001600160a01b0316610257565b6102aa61048636600461272f565b61183e565b61022f610499366004612bb3565b611890565b609754610257906001600160a01b031681565b6102826104bf366004612979565b6118ee565b6104f36104d2366004612979565b60a06020526000908152604090208054600182015460029092015490919083565b6040805193845260208401929092529082015260600161023b565b8160000361052f5760405163adfd6eb360e01b815260040160405180910390fd5b6001600160a01b03811661055657604051633423ddb360e11b815260040160405180910390fd5b6001600160a01b038116600090815260a06020526040902060028101541561059157604051631c98f45d60e01b815260040160405180910390fd5b805461059e908490612c48565b81556097546105b8906001600160a01b031633308661195f565b505050565b805160208083015151604080850151606080870151608088015184519687019790975293811b6001600160601b0319908116938601939093521b1660548301526068820152608881019190915260009060a8015b604051602081830303815290604052805190602001209050919050565b609c54604051635e05e35d60e11b81526004810184905260009182916001600160a01b039091169063bc0bc6ba9060240161012060405180830381865afa15801561067d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106a19190612c8b565b80519091506000036106c65760405163a756193360e01b815260040160405180910390fd5b80518310806106e85750600081604001511180156106e8575080604001518310155b15610706576040516339e9ad8d60e11b815260040160405180910390fd5b60006107128443612d20565b9050816101000151811061072b57600092505050610780565b600061073f8360c0015184608001516119d0565b9050600083610100015183836107559190612d33565b61075f9190612d4a565b905061076a81611a00565b8460c001516107799190612d6c565b9450505050505b92915050565b600054610100900460ff16158080156107a65750600054600160ff909116105b806107c05750303b1580156107c0575060005460ff166001145b6108285760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6000805460ff19166001179055801561084b576000805461ff0019166101001790555b6001600160a01b038a1661087257604051635f5d339960e01b815260040160405180910390fd5b6108a66040518060400160405280600a8152602001695265676973747269657360b01b8152508a637ccc541d60e11b611a6d565b6108de6040518060400160405280600e81526020016d29ba30b5b4b733a6b0b730b3b2b960911b815250896303e0261b60e41b611a6d565b610911604051806040016040528060098152602001684469726563746f727960b81b81525088638a5d64cd60e01b611a6d565b6109486040518060400160405280600d81526020016c22b837b1b439a6b0b730b3b2b960991b8152508763078a0a4b60e41b611a6d565b6109806040518060400160405280600e81526020016d2932bbb0b93239a6b0b730b3b2b960911b81525086631ed895ad60e11b611a6d565b6109bc60405180604001604052806012815260200171417574686f72697a65644163636f756e747360701b815250856337e592f160e21b611a6d565b816000036109dd57604051632d8ef94560e11b815260040160405180910390fd5b6109e5611b71565b609780546001600160a01b03199081166001600160a01b038d8116919091179092556098805482168c84161790556099805482168b8416179055609a805482168a8416179055609c80548216898416179055609b80548216888416179055609d80548216878416179055609e8054909116918516919091179055609f8290558015610aaa576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050505050565b610abf33611070565b565b609c54604051635e05e35d60e11b8152883560048201526000916001600160a01b03169063bc0bc6ba9060240161012060405180830381865afa158015610b0c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b309190612c8b565b90504388608001351115610b5a576040516001623a160d60e21b0319815260040160405180910390fd5b6000610b79610b6e368b90038b018b612713565b888a89898989610c65565b600081815260a160205260408120805460ff19166001179055609a5491935091506001600160a01b0316631bdcc9ad8b35610bba60808e0160608f01612979565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b03166024820152604401602060405180830381865afa158015610c04573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c289190612d93565b905080600003610c4e57604051637f6cbf1960e11b81528a35600482015260240161081f565b610aaa838b610c6060208c018c612979565b611ba0565b60208701515160009081906001600160a01b0316610c965760405163091e31fd60e31b815260040160405180910390fd5b6000610ca560208a018a612979565b6001600160a01b031603610ccc57604051635ff51db760e11b815260040160405180910390fd5b60408901516001600160a01b0316610cf75760405163cab78a2360e01b815260040160405180910390fd5b609e546000906001600160a01b0316634dde5a44610d1860208c018c612979565b6040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602401602060405180830381865afa158015610d5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d809190612dac565b90506001600160a01b038116610dc257610d9d60208a018a612979565b60405163149948a160e31b81526001600160a01b03909116600482015260240161081f565b610dcb8a6105bd565b92508281604051602001610df692919091825260601b6001600160601b031916602082015260340190565b60408051601f198184030181529181528151602092830120600081815260a190935291205490925060ff1615610e3f576040516301faedd760e61b815260040160405180910390fd5b8960800151610e528b606001518a61183e565b14610e705760405163bfec4b7960e01b815260040160405180910390fd5b610e828a602001518b60600151611c44565b610e9f57604051632616fe7d60e11b815260040160405180910390fd5b610ebb610eb1368b90038b018b612dc9565b8b60600151611c44565b610ed8576040516354c4763f60e01b815260040160405180910390fd5b610f1e8a6020015188888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250889250611ce4915050565b610f3b576040516319ad5a6d60e21b815260040160405180910390fd5b610f8b610f4d368b90038b018b612dc9565b86868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250889250611ce4915050565b610fa857604051639bce429160e01b815260040160405180910390fd5b61103487878080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f8b018190048102820181019092528981529250899150889081908401838280828437600081840152601f19601f820116905080830192505050505050508c600001518d606001518c611890565b61105157604051630554a83160e31b815260040160405180910390fd5b5097509795505050505050565b611066611d62565b610abf6000611dbc565b33600090815260a0602052604081206040805160608101825282548152600183015460208201526002909201549082018190529091506000036110c65760405163065bea4960e21b815260040160405180910390fd5b438160400151106110ea576040516366af725560e01b815260040160405180910390fd5b602081015181516000916110fd91612c48565b33600090815260a06020526040812081815560018101829055600201556097549091506105b8906001600160a01b03168483611dd5565b609c54604051635e05e35d60e11b8152873560048201526000916001600160a01b03169063bc0bc6ba9060240161012060405180830381865afa15801561117f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111a39190612c8b565b9050438760c0013511156111cd576040516001623a160d60e21b0319815260040160405180910390fd5b60006111eb6111e1368a90038a018a612b09565b88888888886113c9565b600081815260a160205260408120805460ff19166001179055609a54919250906001600160a01b0316631bdcc9ad8a3561122b60c08d0160a08e01612979565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b03166024820152604401602060405180830381865afa158015611275573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112999190612d93565b9050806000036112bf57604051637f6cbf1960e11b81528935600482015260240161081f565b6112c9838a611e05565b505050505050505050565b60655433906001600160a01b031681146113425760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b606482015260840161081f565b61134b81611dbc565b50565b33600090815260a060205260408120805415801561136e57506001810154155b1561138c57604051639c4e744360e01b815260040160405180910390fd5b6002810154156113af57604051631c98f45d60e01b815260040160405180910390fd5b609f546113bc9043612c48565b6002909101819055919050565b6020860151516000906001600160a01b03166113f85760405163091e31fd60e31b815260040160405180910390fd5b6040870151516001600160a01b031661142457604051635ff51db760e11b815260040160405180910390fd5b60608701516001600160a01b031661144f5760405163cab78a2360e01b815260040160405180910390fd5b61145887611684565b600081815260a1602052604090205490915060ff161561148b576040516301faedd760e61b815260040160405180910390fd5b8660a0015161149e88608001518861183e565b146114bc5760405163bfec4b7960e01b815260040160405180910390fd5b6114ce87602001518860800151611c44565b6114eb57604051632616fe7d60e11b815260040160405180910390fd5b6114fd87604001518860800151611c44565b61151a576040516354c4763f60e01b815260040160405180910390fd5b611560876020015186868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250869250611ce4915050565b61157d576040516319ad5a6d60e21b815260040160405180910390fd5b6115c3876040015184848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250869250611ce4915050565b6115e057604051639bce429160e01b815260040160405180910390fd5b61165d85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f89018190048102820181019092528781529250879150869081908401838280828437600092019190915250508b5160808d015190925090508a611890565b61167a57604051630554a83160e31b815260040160405180910390fd5b9695505050505050565b80516020808301515160408085015151606080870151608088015160a089015185519788019890985294821b6001600160601b03199081169487019490945291811b831660548601521b166068830152607c820152609c81019190915260009060bc01610611565b8160000361170d5760405163ea50132f60e01b815260040160405180910390fd5b6001600160a01b03811661173457604051633423ddb360e11b815260040160405180910390fd5b6001600160a01b038116600090815260a06020526040902060028101541561176f57604051631c98f45d60e01b815260040160405180910390fd5b82816001015461177f9190612c48565b60018201556097546105b8906001600160a01b031633308661195f565b33600090815260a06020526040812060028101549091036117d05760405163065bea4960e21b815260040160405180910390fd5b6000600290910155565b6117e2611d62565b8060000361180357604051632d8ef94560e11b815260040160405180910390fd5b609f8190556040518181527fbf6423edafc706e6ae214d98c485a52f610ee2f23148b43d546af3f8834c21b39060200160405180910390a150565b604080516020810184905290810182905260009060600160408051601f198184030181528282528051602091820120908301520160405160208183030381529060405280519060200120905092915050565b60008061189d858561062e565b6001600160801b03169050600081608083901b179050808888866040516020016118c993929190612e09565b60408051601f1981840301815291905280516020909101201098975050505050505050565b6118f6611d62565b606580546001600160a01b0383166001600160a01b031990911681179091556119276033546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b6040516001600160a01b03808516602483015283166044820152606481018290526119ca9085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611eb6565b50505050565b6000620186a06119ef63ffffffff84166001600160801b038616612d33565b6119f99190612d4a565b9392505050565b60006001600160801b03821115611a695760405162461bcd60e51b815260206004820152602760248201527f53616665436173743a2076616c756520646f65736e27742066697420696e20316044820152663238206269747360c81b606482015260840161081f565b5090565b8251600003611a8f5760405163d1fc12f760e01b815260040160405180910390fd5b6001600160a01b038216611ab6578260405161f56160eb1b815260040161081f9190612e6a565b6001600160e01b03198116611ade5760405163308c995160e01b815260040160405180910390fd5b6040516301ffc9a760e01b81526001600160e01b0319821660048201526001600160a01b038316906301ffc9a790602401602060405180830381865afa158015611b2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b509190612e7d565b6105b8578281604051633f8ccd3b60e21b815260040161081f929190612e9f565b600054610100900460ff16611b985760405162461bcd60e51b815260040161081f90612eca565b610abf611f8b565b6000611bbf8460208501611bba6080870160608801612979565b611fbb565b9050611bd16040840160208501612979565b6001600160a01b0316611bea6080850160608601612979565b604080516001600160a01b038681168252608088013560208301529181018590529116908535907f04562f4c0ee54b401e8fcaafa7daa175963d9bb7a07297633221dc08b1d57b0f9060600160405180910390a450505050565b60208201516000906001600160a01b0316611c6157506001610780565b609d548351602085015160405163c346893b60e01b81526000936001600160a01b03169263c346893b92611c9b9286908990600401612f2b565b602060405180830381865afa158015611cb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cdc9190612e7d565b949350505050565b602083015160009081906001600160a01b031615611d0757506020840151611d0b565b5083515b7f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c849052603c90206001600160a01b038216611d4e8287612098565b6001600160a01b0316149695505050505050565b6033546001600160a01b03163314610abf5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161081f565b606580546001600160a01b031916905561134b816120bc565b6040516001600160a01b0383166024820152604481018290526105b890849063a9059cbb60e01b90606401611993565b6000611e1f8360208401611bba60c0860160a08701612979565b9050611e316040830160208401612979565b6001600160a01b0316611e4a60c0840160a08501612979565b6001600160a01b031683357f7d274bdf94856b1ec309b530c7bf991ea808eb7782afef762e28cce446178907611e866080870160608801612979565b604080516001600160a01b03909216825260c08801356020830152810186905260600160405180910390a4505050565b6000611f0b826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b031661210e9092919063ffffffff16565b9050805160001480611f2c575080806020019051810190611f2c9190612e7d565b6105b85760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b606482015260840161081f565b600054610100900460ff16611fb25760405162461bcd60e51b815260040161081f90612eca565b610abf33611dbc565b600080611fe8611fce6020860186612979565b6001600160a01b0316600090815260a06020526040902090565b9050600081600001548660a00151111561207e5750805461200a84838361211d565b6097546001830154612029916001600160a01b03169061dead90611dd5565b600060018301557f2ec87e1ff3f5b311fa539eb48a387afc2e82e11ac9919086426f16c1b35cfe8561205e6020870187612979565b6040516001600160a01b03909116815260200160405180910390a161208f565b5060a085015161208f84838361211d565b95945050505050565b60008060006120a785856121b4565b915091506120b4816121f9565b509392505050565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6060611cdc8484600085612343565b815461212a908290612d20565b8255609754609b54612149916001600160a01b03908116911683611dd5565b609b546040516340768fd360e01b81526001600160a01b03858116600483015260248201849052909116906340768fd390604401600060405180830381600087803b15801561219757600080fd5b505af11580156121ab573d6000803e3d6000fd5b50505050505050565b60008082516041036121ea5760208301516040840151606085015160001a6121de8782858561241e565b945094505050506121f2565b506000905060025b9250929050565b600081600481111561220d5761220d612f15565b036122155750565b600181600481111561222957612229612f15565b036122765760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e61747572650000000000000000604482015260640161081f565b600281600481111561228a5761228a612f15565b036122d75760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e67746800604482015260640161081f565b60038160048111156122eb576122eb612f15565b0361134b5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b606482015260840161081f565b6060824710156123a45760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b606482015260840161081f565b600080866001600160a01b031685876040516123c09190612f73565b60006040518083038185875af1925050503d80600081146123fd576040519150601f19603f3d011682016040523d82523d6000602084013e612402565b606091505b5091509150612413878383876124e2565b979650505050505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561245557506000905060036124d9565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa1580156124a9573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166124d2576000600192509250506124d9565b9150600090505b94509492505050565b6060831561255157825160000361254a576001600160a01b0385163b61254a5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161081f565b5081611cdc565b611cdc83838151156125665781518083602001fd5b8060405162461bcd60e51b815260040161081f9190612e6a565b60006020828403121561259257600080fd5b81356001600160e01b0319811681146119f957600080fd5b6001600160a01b038116811461134b57600080fd5b600080604083850312156125d257600080fd5b8235915060208301356125e4816125aa565b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b604051610120810167ffffffffffffffff81118282101715612629576126296125ef565b60405290565b60006040828403121561264157600080fd5b6040516040810181811067ffffffffffffffff82111715612664576126646125ef565b6040529050808235612675816125aa565b81526020830135612685816125aa565b6020919091015292915050565b600060c082840312156126a457600080fd5b60405160a0810181811067ffffffffffffffff821117156126c7576126c76125ef565b604052823581529050806126de846020850161262f565b602082015260608301356126f1816125aa565b806040830152506080830135606082015260a083013560808201525092915050565b600060c0828403121561272557600080fd5b6119f98383612692565b6000806040838503121561274257600080fd5b50508035926020909101359150565b60008060008060008060008060006101208a8c03121561277057600080fd5b893561277b816125aa565b985060208a013561278b816125aa565b975060408a013561279b816125aa565b965060608a01356127ab816125aa565b955060808a01356127bb816125aa565b945060a08a01356127cb816125aa565b935060c08a01356127db816125aa565b925060e08a01356127eb816125aa565b809250506101008a013590509295985092959850929598565b60006040828403121561281657600080fd5b50919050565b60008083601f84011261282e57600080fd5b50813567ffffffffffffffff81111561284657600080fd5b6020830191508360208285010111156121f257600080fd5b600080600080600080600087890361016081121561287b57600080fd5b60c081121561288957600080fd5b5087965060c088013595506128a18960e08a01612804565b945061012088013567ffffffffffffffff808211156128bf57600080fd5b6128cb8b838c0161281c565b90965094506101408a01359150808211156128e557600080fd5b506128f28a828b0161281c565b989b979a50959850939692959293505050565b60006020828403121561291757600080fd5b5035919050565b6000806000806000806000610160888a03121561293a57600080fd5b6129448989612692565b96506129538960c08a01612804565b9550610100880135945061012088013567ffffffffffffffff808211156128bf57600080fd5b60006020828403121561298b57600080fd5b81356119f9816125aa565b6000806000806000808688036101608112156129b157600080fd5b610100808212156129c157600080fd5b88975087013595505061012086013567ffffffffffffffff808211156129e657600080fd5b6129f28a838b0161281c565b9096509450610140890135915080821115612a0c57600080fd5b50612a1989828a0161281c565b979a9699509497509295939492505050565b60006101008284031215612a3e57600080fd5b60405160c0810181811067ffffffffffffffff82111715612a6157612a616125ef565b60405282358152905080612a78846020850161262f565b6020820152612a8a846060850161262f565b604082015260a0830135612a9d816125aa565b8060608301525060c0830135608082015260e083013560a08201525092915050565b6000806000806000806101608789031215612ad957600080fd5b612ae38888612a2b565b9550610100870135945061012087013567ffffffffffffffff808211156129e657600080fd5b60006101008284031215612b1c57600080fd5b6119f98383612a2b565b600082601f830112612b3757600080fd5b813567ffffffffffffffff80821115612b5257612b526125ef565b604051601f8301601f19908116603f01168101908282118183101715612b7a57612b7a6125ef565b81604052838152866020858801011115612b9357600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080600060a08688031215612bcb57600080fd5b853567ffffffffffffffff80821115612be357600080fd5b612bef89838a01612b26565b96506020880135915080821115612c0557600080fd5b50612c1288828901612b26565b959895975050505060408401359360608101359360809091013592509050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561078057610780612c32565b805163ffffffff81168114612c6f57600080fd5b919050565b80516001600160801b0381168114612c6f57600080fd5b60006101208284031215612c9e57600080fd5b612ca6612605565b825181526020830151602082015260408301516040820152612cca60608401612c5b565b6060820152612cdb60808401612c5b565b608082015260a083015160a0820152612cf660c08401612c74565b60c0820152612d0760e08401612c74565b60e0820152610100928301519281019290925250919050565b8181038181111561078057610780612c32565b808202811582820484141761078057610780612c32565b600082612d6757634e487b7160e01b600052601260045260246000fd5b500490565b6001600160801b03828116828216039080821115612d8c57612d8c612c32565b5092915050565b600060208284031215612da557600080fd5b5051919050565b600060208284031215612dbe57600080fd5b81516119f9816125aa565b600060408284031215612ddb57600080fd5b6119f9838361262f565b60005b83811015612e00578181015183820152602001612de8565b50506000910152565b60008451612e1b818460208901612de5565b845190830190612e2f818360208901612de5565b01928352505060200192915050565b60008151808452612e56816020860160208601612de5565b601f01601f19169290920160200192915050565b6020815260006119f96020830184612e3e565b600060208284031215612e8f57600080fd5b815180151581146119f957600080fd5b604081526000612eb26040830185612e3e565b905063ffffffff60e01b831660208301529392505050565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b038581168252841660208201526080810160018410612f6157634e487b7160e01b600052602160045260246000fd5b60408201939093526060015292915050565b60008251612f85818460208701612de5565b919091019291505056fea2646970667358221220df15c9ce639d482fafc3d321375e7ebc8cd7cfc4ec1c8617ea0c1d536d6c317e64736f6c63430008120033",
  "devdoc": {
    "events": {
      "Initialized(uint8)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "kind": "dev",
    "methods": {
      "acceptOwnership()": {
        "details": "The new owner accepts the ownership transfer."
      },
      "calculateWinningProbability(uint256,uint256)": {
        "params": {
          "epochId": "The epochId of the ticket.",
          "generationBlock": "The generationBlock of the ticket."
        }
      },
      "depositEscrow(uint256,address)": {
        "params": {
          "account": "The address of the account holding the escrow.",
          "amount": "The amount in SOLO to add to the escrow."
        }
      },
      "depositPenalty(uint256,address)": {
        "params": {
          "account": "The address of the account holding the penalty.",
          "amount": "The amount in SOLO to add to the escrow."
        }
      },
      "getMultiReceiverTicketHash((uint256,(address,address),address,uint256,bytes32))": {
        "returns": {
          "_0": "A byte-array representing the hash."
        }
      },
      "getTicketHash((uint256,(address,address),(address,address),address,uint256,bytes32))": {
        "returns": {
          "_0": "A byte-array representing the hash."
        }
      },
      "isWinningTicket(bytes,bytes,uint256,uint256,uint256)": {
        "params": {
          "epochId": "The epochId of the ticket.",
          "generationBlock": "The generationBlock of the ticket.",
          "receiverSig": "The signature of the receiver of the ticket.",
          "redeemerRand": "The redeemer random value, generated by the Node prior to performing the event relay.",
          "senderSig": "The signature of the sender of the ticket."
        },
        "returns": {
          "_0": "True if a ticket is a winner."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "pendingOwner()": {
        "details": "Returns the address of the pending owner."
      },
      "redeem((uint256,(address,address),(address,address),address,uint256,bytes32),uint256,bytes,bytes)": {
        "params": {
          "receiverSig": "The signature of the redeemer of the ticket.",
          "redeemerRand": "The redeemer random value, generated by the Node prior to performing the event relay.",
          "senderSig": "The signature of the sender of the ticket.",
          "ticket": "The ticket issued by the sender."
        }
      },
      "redeemMultiReceiver((uint256,(address,address),address,uint256,bytes32),uint256,(address,address),bytes,bytes)": {
        "params": {
          "receiver": "A valid receiver of the the relay.",
          "receiverSig": "The signature of the redeemer of the ticket.",
          "redeemerRand": "The redeemer random value, generated by the Node prior to performing the event relay.",
          "senderSig": "The signature of the sender of the ticket.",
          "ticket": "The ticket issued by the sender."
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "requireValidWinningMultiReceiverTicket((uint256,(address,address),address,uint256,bytes32),(address,address),uint256,bytes,bytes)": {
        "params": {
          "receiver": "The receiver associated with the ticket.",
          "receiverSig": "The signature of the redeemer of the ticket.",
          "redeemerRand": "The redeemer random value, generated by the Node prior to performing the event relay.",
          "senderSig": "The signature of the sender of the ticket.",
          "ticket": "The ticket issued by the sender."
        }
      },
      "requireValidWinningTicket((uint256,(address,address),(address,address),address,uint256,bytes32),uint256,bytes,bytes)": {
        "params": {
          "receiverSig": "The signature of the redeemer of the ticket.",
          "redeemerRand": "The redeemer random value, generated by the Node prior to performing the event relay.",
          "senderSig": "The signature of the sender of the ticket.",
          "ticket": "The ticket issued by the sender."
        },
        "returns": {
          "ticketHash": "The hash of the ticket. Should match the hash generated by `getTicketHash`."
        }
      },
      "setUnlockDuration(uint256)": {
        "params": {
          "_unlockDuration": "The unlock duration in blocks."
        }
      },
      "transferOwnership(address)": {
        "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner."
      },
      "withdrawTo(address)": {
        "params": {
          "account": "The address of the account the tokens should be transferred to."
        }
      }
    },
    "stateVariables": {
      "_epochsManager": {
        "details": "The ticketing parameters used when redeeming tickets will be read from this contract."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "_authorizedAccounts()": {
        "notice": "Sylo Authorized Accounts."
      },
      "_directory()": {
        "notice": "Sylo Directory contract "
      },
      "_epochsManager()": {
        "notice": "Sylo Epochs Manager."
      },
      "_futurepassRegistrar()": {
        "notice": "Futurepass Registrar Pre-compile."
      },
      "_registries()": {
        "notice": "Sylo Registries contract "
      },
      "_rewardsManager()": {
        "notice": "Rewards Manager contract "
      },
      "_stakingManager()": {
        "notice": "Sylo Staking Manager contract "
      },
      "_token()": {
        "notice": "ERC20 Sylo token contract."
      },
      "calculateWinningProbability(uint256,uint256)": {
        "notice": "This function calculates the probability of a ticket winning at the block that this function was called. A ticket's winning probability will decay every block since its issuance. The amount of decay will depend on the decay rate parameter of the epoch the ticket was generated in."
      },
      "depositEscrow(uint256,address)": {
        "notice": "Use this function to deposit funds into the escrow. This will fail if the deposit is currently being unlocked."
      },
      "depositPenalty(uint256,address)": {
        "notice": "Use this function to deposit funds into the penalty. This will fail if the deposit is currently being unlocked."
      },
      "deposits(address)": {
        "notice": "Mapping of user deposits "
      },
      "getMultiReceiverTicketHash((uint256,(address,address),address,uint256,bytes32))": {
        "notice": "Returns the hash of a multi receiver ticket. Takes all fields in a ticket as inputs to the hash, as well as a specific receiver."
      },
      "getTicketHash((uint256,(address,address),(address,address),address,uint256,bytes32))": {
        "notice": "Returns the hash of the ticket. Takes all fields in a ticket as inputs to the hash."
      },
      "isWinningTicket(bytes,bytes,uint256,uint256,uint256)": {
        "notice": "Use this function to check if a ticket is winning."
      },
      "lockDeposits()": {
        "notice": "Call this function to cancel any deposit that is in the unlocking process."
      },
      "redeem((uint256,(address,address),(address,address),address,uint256,bytes32),uint256,bytes,bytes)": {
        "notice": "Nodes should call this function on completing an event delivery. This function will fail if the ticket is invalid or if the ticket is not a winner. Clients should calculate if the ticket is a winner locally, but can also use the public view functions: `requireValidWinningTicket` and `isWinningTicket` to check that a ticket is winning."
      },
      "redeemMultiReceiver((uint256,(address,address),address,uint256,bytes32),uint256,(address,address),bytes,bytes)": {
        "notice": "Nodes should call this function on completing a one-to-many event delivery. This function will fail if the ticket is invalid or if the ticket is not a winner. Additionally, the specified receiver must have a valid futurepass account associated with it. Clients should calculate if the ticket is a winner locally, but can also use the public view functions: `requireValidWinningMultiReceiverTicket` and `isWinningTicket` to check that a ticket is winning."
      },
      "requireValidWinningMultiReceiverTicket((uint256,(address,address),address,uint256,bytes32),(address,address),uint256,bytes,bytes)": {
        "notice": "Call this function to check if a multi receiver ticket is valid and is a winning ticket. It will fail if the ticket is invalid or is not a winner. A ticket is invalid if:      - The sender, receiver or redeemer addresses are null      - The receiver does not have a valid futurepass account      - The ticket has already been redeemed.      - The secret random value of the redeemer does not match the commit        in the ticket.      - The signatures are invalid."
      },
      "requireValidWinningTicket((uint256,(address,address),(address,address),address,uint256,bytes32),uint256,bytes,bytes)": {
        "notice": "Call this function to check if a ticket is valid and is a winning ticket. It will fail if the ticket is invalid or is not a winner. A ticket is invalid if:      - The sender or redeemer addresses are null      - The ticket has already been redeemed.      - The secret random value of the sender does not match the commit        in the ticket.      - The signatures are invalid."
      },
      "setUnlockDuration(uint256)": {
        "notice": "Set the unlock duration for deposits. Only callable by the owner."
      },
      "supportsInterface(bytes4)": {
        "notice": "Returns true if the contract implements the interface defined by `interfaceId` from ERC165."
      },
      "unlockDeposits()": {
        "notice": "Call this function to begin unlocking deposits. This function will fail if no deposit exists, or if the unlock process has already begun."
      },
      "unlockDuration()": {
        "notice": "The number of blocks a user must wait after calling \"unlock\" before they can withdraw their funds."
      },
      "usedTickets(bytes32)": {
        "notice": "Mapping of ticket hashes, used to check if a ticket has been redeemed "
      },
      "withdraw()": {
        "notice": "Call this function once the unlock duration has elapsed in order to transfer the unlocked tokens to the caller's account."
      },
      "withdrawTo(address)": {
        "notice": "Call this function once the unlock duration has elapsed in order to transfer the unlocked tokens to the specified account."
      }
    },
    "notice": "The SyloTicketing contract manages the Probabilistic Micro-Payment Ticketing system that pays Nodes for providing the Event Relay service.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 244,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 247,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 777,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 116,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_owner",
        "offset": 0,
        "slot": "51",
        "type": "t_address"
      },
      {
        "astId": 236,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 25,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "101",
        "type": "t_address"
      },
      {
        "astId": 104,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 11356,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_token",
        "offset": 0,
        "slot": "151",
        "type": "t_contract(IERC20)1443"
      },
      {
        "astId": 11360,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_registries",
        "offset": 0,
        "slot": "152",
        "type": "t_contract(Registries)9641"
      },
      {
        "astId": 11364,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_stakingManager",
        "offset": 0,
        "slot": "153",
        "type": "t_contract(StakingManager)15921"
      },
      {
        "astId": 11368,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_directory",
        "offset": 0,
        "slot": "154",
        "type": "t_contract(Directory)14978"
      },
      {
        "astId": 11372,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_rewardsManager",
        "offset": 0,
        "slot": "155",
        "type": "t_contract(RewardsManager)14142"
      },
      {
        "astId": 11376,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_epochsManager",
        "offset": 0,
        "slot": "156",
        "type": "t_contract(EpochsManager)10429"
      },
      {
        "astId": 11380,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_authorizedAccounts",
        "offset": 0,
        "slot": "157",
        "type": "t_contract(AuthorizedAccounts)9090"
      },
      {
        "astId": 11384,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "_futurepassRegistrar",
        "offset": 0,
        "slot": "158",
        "type": "t_contract(IFuturePassRegistrar)10523"
      },
      {
        "astId": 11387,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "unlockDuration",
        "offset": 0,
        "slot": "159",
        "type": "t_uint256"
      },
      {
        "astId": 11393,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "deposits",
        "offset": 0,
        "slot": "160",
        "type": "t_mapping(t_address,t_struct(Deposit)10703_storage)"
      },
      {
        "astId": 11398,
        "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
        "label": "usedTickets",
        "offset": 0,
        "slot": "161",
        "type": "t_mapping(t_bytes32,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(AuthorizedAccounts)9090": {
        "encoding": "inplace",
        "label": "contract AuthorizedAccounts",
        "numberOfBytes": "20"
      },
      "t_contract(Directory)14978": {
        "encoding": "inplace",
        "label": "contract Directory",
        "numberOfBytes": "20"
      },
      "t_contract(EpochsManager)10429": {
        "encoding": "inplace",
        "label": "contract EpochsManager",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)1443": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IFuturePassRegistrar)10523": {
        "encoding": "inplace",
        "label": "contract IFuturePassRegistrar",
        "numberOfBytes": "20"
      },
      "t_contract(Registries)9641": {
        "encoding": "inplace",
        "label": "contract Registries",
        "numberOfBytes": "20"
      },
      "t_contract(RewardsManager)14142": {
        "encoding": "inplace",
        "label": "contract RewardsManager",
        "numberOfBytes": "20"
      },
      "t_contract(StakingManager)15921": {
        "encoding": "inplace",
        "label": "contract StakingManager",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(Deposit)10703_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct ISyloTicketing.Deposit)",
        "numberOfBytes": "32",
        "value": "t_struct(Deposit)10703_storage"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_struct(Deposit)10703_storage": {
        "encoding": "inplace",
        "label": "struct ISyloTicketing.Deposit",
        "members": [
          {
            "astId": 10698,
            "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
            "label": "escrow",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 10700,
            "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
            "label": "penalty",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 10702,
            "contract": "contracts/payments/SyloTicketing.sol:SyloTicketing",
            "label": "unlockAt",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}